(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{1440:function(s,t,a){"use strict";a.r(t);var e=a(26),r=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"_1-mysql分表分库简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql分表分库简介"}},[s._v("#")]),s._v(" 1. Mysql分表分库简介")]),s._v(" "),e("h2",{attrs:{id:"_1-1-replication常用架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-replication常用架构"}},[s._v("#")]),s._v(" 1.1 Replication常用架构")]),s._v(" "),e("h3",{attrs:{id:"_1-1-1-数据库扩展解决了什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-数据库扩展解决了什么问题"}},[s._v("#")]),s._v(" 1.1.1 数据库扩展解决了什么问题")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("数据安全")])])]),s._v(" "),e("p",[s._v("给主服务增加一个数据备份。基于这个目的，可以搭建主从架构，或者也可以基\n于主从架构搭建互主的架构。")]),s._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("strong",[s._v("读写分离")])])]),s._v(" "),e("p",[s._v("对于大部分的JAVA业务系统来说，都是读多写少的，读请求远远高于写请求。这时，当主服务的访问压力过大时，可以将数据读请求转为由从服务来分担，主服务只负责数据写入的请求，这样大大缓解数据库的访问压力。")]),s._v(" "),e("p",[s._v("要理解，MySQL的主从架构只是实现读写分离的一个基础。实现读写分离还是需要一些中间件来支持，比如"),e("strong",[s._v("ShardingSphere")]),s._v("。")]),s._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("strong",[s._v("故障转移-高可用")])])]),s._v(" "),e("p",[s._v("当MySQL主服务宕机后，可以由一台从服务切换成为主服务，继续提供数据读写功能。")]),s._v(" "),e("p",[s._v("对于高可用架构，主从数据的同步也只是实现故障转移的一个前提条件，"),e("strong",[s._v("要实现MySQL主从切换，还需要依靠一些其他的中间件来实现。比如MMM、MHA、MGR")]),s._v("。")]),s._v(" "),e("h3",{attrs:{id:"_1-1-2-master-slaves"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-master-slaves"}},[s._v("#")]),s._v(" 1.1.2 Master--Slaves")]),s._v(" "),e("p",[s._v("在实际应用场景中，MySQL 复制 90% 以上都是一个 Master 复制到一个或者多个Slave 的架构模式")]),s._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[s._v("缺点：")]),s._v(" "),e("ol",[e("li",[e("p",[s._v("master不能停机，停机就不能接收写请求")])]),s._v(" "),e("li",[e("p",[s._v("slave过多会出现延迟")])]),s._v(" "),e("li",[e("p",[s._v("由于master需要进行常规维护停机了，那么必须要把一个slave提成master，选哪一个是一个问题？")]),s._v(" "),e("p",[s._v("某一个slave提成master了，就存在当前master和之前的master数据不一致的情况，并且之前master并没有保存当前master节点的binlog文件和pos位置")])])])]),s._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"mysql",href:"./image/mysql32.jpg"}},[e("img",{attrs:{src:a(724),alt:"mysql"}})])]),s._v(" "),e("h3",{attrs:{id:"_1-1-3-dual-master复制架构-master-master-master"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-3-dual-master复制架构-master-master-master"}},[s._v("#")]),s._v(" 1.1.3 Dual Master复制架构(Master--Master) Master)")]),s._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"mysql",href:"./image/mysql33.jpg"}},[e("img",{attrs:{src:a(725),alt:"mysql"}})])]),s._v(" "),e("p",[s._v("可以配合一个第三方的工具，比如keepalived轻松做到IP的漂移，停机维护也不会影响写操作。")]),s._v(" "),e("h3",{attrs:{id:"_1-1-4-级联复制架构-master-slaves-slaves"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-4-级联复制架构-master-slaves-slaves"}},[s._v("#")]),s._v(" 1.1.4 级联复制架构(Master--Slaves--Slaves..)..)")]),s._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"mysql",href:"./image/mysql34.jpg"}},[e("img",{attrs:{src:a(726),alt:"mysql"}})])]),s._v(" "),e("p",[s._v("如果读压力加大，就需要更多的slave来解决，但是如果slave的复制全部从master复制，势必会加大master的复制IO的压力，所以就出现了级联复制，减轻master压力。")]),s._v(" "),e("p",[s._v("缺点：slave延迟更加大了")]),s._v(" "),e("h3",{attrs:{id:"_1-1-5-dual-master与级联复制结合架构-master-master-slaves"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-5-dual-master与级联复制结合架构-master-master-slaves"}},[s._v("#")]),s._v(" 1.1.5 Dual Master与级联复制结合架构(Master-Master-Slaves)")]),s._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"mysql",href:"./image/mysql35.jpg"}},[e("img",{attrs:{src:a(727),alt:"mysql"}})])]),s._v(" "),e("p",[s._v("这样解决了单点master的问题，解决了slave级联延迟的问题.")]),s._v(" "),e("h2",{attrs:{id:"_1-2-replication机制的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-replication机制的实现原理"}},[s._v("#")]),s._v(" 1.2 Replication机制的实现原理")]),s._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"mysql",href:"./image/mysql31.jpg"}},[e("img",{attrs:{src:a(728),alt:"mysql"}})])]),s._v(" "),e("p",[s._v("MySQL服务的主从架构一般都是通过"),e("strong",[s._v("binlog日志文件来进行的")]),s._v("。")]),s._v(" "),e("p",[s._v("即在主服务上打开binlog记录每一步的数据库操作，然后从服务上会有一个"),e("strong",[s._v("IO线程")]),s._v("，负责跟主服务建立一个TCP连接，请求主服务将binlog传输过来。")]),s._v(" "),e("p",[s._v("这时，主库上会有一个"),e("strong",[s._v("IO dump线程")]),s._v("，负责通过这个TCP连接把Binlog日志传输给从库的IO线程。接着从服务的IO线程会把读取到的binlog日志数据写入自己的relay日志文件中。")]),s._v(" "),e("p",[s._v("然后从服务上另外一个SQL线程会读取relay日志里的内容，进行操作重演，达到还原数据的目的。我们通常对MySQL做的读写分离配置就必须基于主从架构来搭建")]),s._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"mysql",href:"./image/mysql36.jpg"}},[e("img",{attrs:{src:a(729),alt:"mysql"}})])]),s._v(" "),e("p",[s._v("MySQL的binlog不光可以用于主从同步，还可以用于缓存数据同步等场景。")]),s._v(" "),e("p",[s._v("例如Canal，"),e("strong",[s._v("可以模拟一个slave节点，向MySQL发起binlog同步，然后将数据落地到Redis、Kafka等其他组件，实现数据实时流转")])]),s._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[s._v("搭建主从集群必要要求：")]),s._v(" "),e("ol",[e("li",[s._v("双方MySQL必须版本一致。至少需要主服务的版本低于从服务")]),s._v(" "),e("li",[s._v("两节点间的时间需要同步")])])])])}),[],!1,null,null,null);t.default=r.exports},724:function(s,t,a){s.exports=a.p+"assets/img/mysql32.c7258573.jpg"},725:function(s,t,a){s.exports=a.p+"assets/img/mysql33.853b7fcb.jpg"},726:function(s,t,a){s.exports=a.p+"assets/img/mysql34.7c155c5f.jpg"},727:function(s,t,a){s.exports=a.p+"assets/img/mysql35.fc90666a.jpg"},728:function(s,t,a){s.exports=a.p+"assets/img/mysql31.eed5657b.jpg"},729:function(s,t,a){s.exports=a.p+"assets/img/mysql36.219d2bdb.jpg"}}]);