(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{799:function(t,s,a){"use strict";a.r(s);var e=a(26),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"解释器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释器模式"}},[t._v("#")]),t._v(" 解释器模式")]),t._v(" "),a("h2",{attrs:{id:"解释器模式基本介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释器模式基本介绍"}},[t._v("#")]),t._v(" 解释器模式基本介绍")]),t._v(" "),a("ol",[a("li",[t._v("在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器")]),t._v(" "),a("li",[t._v("解释器模式（Interpreter Pattern）：是指给定一个语言(表达式)，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式)")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("解释器模式的注意事项和细节")]),t._v(" "),a("ol",[a("li",[t._v("当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性")]),t._v(" "),a("li",[t._v("应用场景：编译器、运算表达式计算、正则表达式、机器人等\n使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);