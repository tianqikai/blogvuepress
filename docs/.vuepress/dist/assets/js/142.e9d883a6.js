(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{1066:function(c,t,n){"use strict";n.r(t);var v=n(26),e=Object(v.a)({},(function(){var c=this,t=c.$createElement,n=c._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":c.$parent.slotKey}},[n("h1",{attrs:{id:"_10-mvcc的理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-mvcc的理解"}},[c._v("#")]),c._v(" 10. Mvcc的理解")]),c._v(" "),n("p",[c._v("我觉得可以从数据库的三种并发场景来说，\n第一种是如何读的并发，就是两个县城a和b同时进行同步操作，这种情况下不会产生任何的并发问题。")]),c._v(" "),n("p",[c._v("第二组是读写地方，就是两个线程a和b在同一个时刻分别进行读写操作，这种情况下可能会对数据库的数据造成以下的一些问题。\n第一个事物隔离性问题，\n第二个会出现脏读、幻读和不可重复读的问题。")]),c._v(" "),n("p",[c._v("第三种写和写的并发，就是两个线程a和b同时进行写操作，这种情况下可能会存在数据更新的丢失问题，而mvcc就是为了解决事务操作中并发安全问题的，")]),c._v(" "),n("p",[c._v("无锁并发控制技术全都是Marty version currency CTRL也就是多版本地方控制，它是通过数据库记录中的隐式字段mu日志和vdu来实现的。\nMvcd主要解决三个问题，\n第一个是通过mvcc可以解决读写并发阻塞的问题，从而提高数据的并发处理能力。\n第二个是mvcc采用的是乐观锁的方式实现，降低了死锁的概率。\n第三个解决了一致性读的问题，也就是事物启动时候根据某个条件去读取到数据，直到事物结束的时候再去执行相同的条件，还是读到同一份数据不会发生变化")]),c._v(" "),n("p",[c._v("而我们在使用mvcc的时候，一般是根据业务场景来选择组合搭配乐观锁或者悲观锁。这两个组合中mvcc用来解决读写冲突、乐观锁或者悲观锁用来解决写和写的冲突，从而最大程度的去提高数据库的并发性能。\n以上就是我对mvcc的一个理解。")])])}),[],!1,null,null,null);t.default=e.exports}}]);