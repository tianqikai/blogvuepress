(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{1657:function(_,v,e){"use strict";e.r(v);var n=e(26),s=Object(n.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"_1-acid靠什么保证的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-acid靠什么保证的"}},[_._v("#")]),_._v(" 1. ACID靠什么保证的？")]),_._v(" "),e("ul",[e("li",[_._v("A 原子性由"),e("code",[_._v("undo log日志")]),_._v("保证，它记录了需要"),e("code",[_._v("回滚的日志信息")]),_._v("，事务回滚时撤销已经执行成功的sql")]),_._v(" "),e("li",[_._v("C 一致性由其他三大特性保证、程序代码要保证业务上的一致性")]),_._v(" "),e("li",[_._v("I 隔离性由"),e("code",[_._v("MVCC来保证")])]),_._v(" "),e("li",[_._v("D 持久性由"),e("code",[_._v("内存+redo log")]),_._v("来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从"),e("code",[_._v("redo log恢复")])])]),_._v(" "),e("h1",{attrs:{id:"_2-b树和b-树的区别-为什么mysql使用b-树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-b树和b-树的区别-为什么mysql使用b-树"}},[_._v("#")]),_._v(" 2. B树和B+树的区别，为什么Mysql使⽤B+树")]),_._v(" "),e("p",[e("strong",[_._v("B树特点：")])]),_._v(" "),e("ol",[e("li",[_._v("节点排序")]),_._v(" "),e("li",[_._v("⼀个节点了可以存多个元素，多个元素也排序了")])]),_._v(" "),e("p",[e("strong",[_._v("B+树的特点：")])]),_._v(" "),e("ol",[e("li",[_._v("拥有B树的特点")]),_._v(" "),e("li",[_._v("叶⼦节点之间有指针")]),_._v(" "),e("li",[e("code",[_._v("⾮叶⼦节点上的元素在叶⼦节点上都冗余")]),_._v("了，也就是叶⼦节点中存储了所有的元素，并且排好顺序")])]),_._v(" "),e("p",[_._v("Mysql索引使⽤的是B+树，因为索引是⽤来加快查询的，⽽B+树通过对数据进⾏排序所以是可以提⾼查询 速度的，然后通过⼀个节点中可以存储多个元素，从⽽可以使得B+树的⾼度不会太⾼，在Mysql中⼀个 Innodb⻚就是⼀个B+树节点，⼀个Innodb⻚默认16kb，所以⼀般情况下⼀颗两层的B+树可以存2000万 ⾏左右的数据，然后通过利⽤B+树叶⼦节点存储了所有数据并且进⾏了排序，并且叶⼦节点之间有指针， 可以很好的⽀持全表扫描，范围查找等SQL语句")]),_._v(" "),e("h1",{attrs:{id:"_3-explain执行计划的各个字段是干什么用的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-explain执行计划的各个字段是干什么用的"}},[_._v("#")]),_._v(" 3. Explain执行计划的各个字段是干什么用的？")]),_._v(" "),e("p",[_._v("id： 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id\nselect_type： SELECT 关键字对应的那个查询的类型\ntable：表名\npartitions：匹配的分区信息\ntype：针对单表的访问方法\npossible_keys：可能用到的索引\nkey：实际上使用的索引\nkey_len：实际使用到的索引长度\nref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息\nrows：预估的需要读取的记录条数\nfiltered：某个表经过搜索条件过滤后剩余记录条数的百分比\nExtra：—些额外的信息")]),_._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("p",[_._v("selectType 表示查询中每个select子句的类型\nSIMPLE： 表示此查询不包含 UNION 查询或子查询\nPRIMARY： 表示此查询是最外层的查询（包含子查询）\nSUBQUERY： 子查询中的第一个 SELECT\nUNION： 表示此查询是 UNION 的第二或随后的查询\nDEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询\nUNION RESULT, UNION 的结果\nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.\nDERIVED：衍生，表示导出表的SELECT（FROM子句的子查询）")])]),_._v(" "),e("li",[e("p",[_._v("type：优化sql的重要字段，也是我们判断sql性能和优化程度重要指标。他的取值类型范围：\nconst：通过索引一次命中，匹配一行数据\nsystem: 表中只有一行记录，相当于系统表；\neq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配\nref: 非唯一性索引扫描,返回匹配某个值的所有\nrange: 只检索给定范围的行，使用一个索引来选择行，一般用于between、<、>；\nindex: 只遍历索引树；\nALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多，执行效率越慢。")])])]),_._v(" "),e("h1",{attrs:{id:"_4-innodb是如何实现事务的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-innodb是如何实现事务的"}},[_._v("#")]),_._v(" 4. Innodb是如何实现事务的")]),_._v(" "),e("p",[_._v("Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例：")]),_._v(" "),e("ol",[e("li",[_._v("Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在"),e("code",[_._v("Buffer Pool")]),_._v(" 中")]),_._v(" "),e("li",[_._v("执⾏update语句，修改"),e("code",[_._v("Buffer Pool")]),_._v("中的数据，也就是内存中的数据")]),_._v(" "),e("li",[_._v("针对update语句⽣成⼀个"),e("code",[_._v("RedoLog对象")]),_._v("，并存⼊"),e("code",[_._v("LogBuffer中")])]),_._v(" "),e("li",[_._v("针对update语句⽣成undolog⽇志，⽤于事务回滚")]),_._v(" "),e("li",[_._v("如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将"),e("code",[_._v("Buffer Pool中所修改的数据⻚持久化到磁盘中")])]),_._v(" "),e("li",[_._v("如果事务回滚，则利⽤undolog⽇志进⾏回滚")])]),_._v(" "),e("h1",{attrs:{id:"_5-mysql的索引结构是什么样的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-mysql的索引结构是什么样的"}},[_._v("#")]),_._v(" 5. MySQL的索引结构是什么样的")]),_._v(" "),e("p",[_._v("聚簇索引就是数据和索引是在一起的。")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("MyISAM使用的是非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址。InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。")])]),_._v(" "),e("li",[e("p",[_._v("聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。")])]),_._v(" "),e("li",[e("p",[_._v("InnoDB中，如果表定义了PK，"),e("code",[_._v("那PK就是聚簇索引")]),_._v("。 如果没有PK，就会找第一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。")])])]),_._v(" "),e("h1",{attrs:{id:"_6-mysql的覆盖索引和回表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-mysql的覆盖索引和回表"}},[_._v("#")]),_._v(" 6 MySQL的覆盖索引和回表")]),_._v(" "),e("p",[_._v("如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查\n询，这样查询速度就可以更快。\n实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。\nuser（PK id , name ,sex）\nselect count(name) from user ; -> 在name 字段上建立一个索引。\nselect id , name ,sex from user; -> 将name上的索引升级成为(name,sex)的联合\n索引。")]),_._v(" "),e("h1",{attrs:{id:"_7-mysql的集群是如何搭建的-读写分离是怎么做的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-mysql的集群是如何搭建的-读写分离是怎么做的"}},[_._v("#")]),_._v(" 7. MySQL的集群是如何搭建的？读写分离是怎么做的？")]),_._v(" "),e("p",[_._v("这时，主库上会有一个"),e("code",[_._v("IO dump线程")]),_._v("，负责通过这个TCP连接把Binlog日志传输给从库的IO线程。接着从服务的"),e("code",[_._v("IO线程")]),_._v("会把读取到的"),e("code",[_._v("binlog日志")]),_._v("数据写入自己的relay日志文件中。")]),_._v(" "),e("p",[_._v("然后从服务上另外一个"),e("code",[_._v("SQL线程")]),_._v("会读取relay日志里的内容，进行操作重演，达到还原数据的目的。我们通常对MySQL做的读写分离配置就必须基于主从架构来搭建")]),_._v(" "),e("p",[_._v("主从架构异步复制可能存在丢数据的情况，可以使用"),e("code",[_._v("半同步方式")])]),_._v(" "),e("p",[_._v("这种半同步复制相比异步复制，能够有效的提高数据的安全性。但是这种安全性也不是绝对的，他只保证事务提交后的binlog至少传输到了一个从库，并且并不保证从库应用这个事务的binlog是成功的。另一方面，半同步复制机制也会造成一定程度的延迟，这个延迟时间最少是一个TCP/IP请求往返的时间。整个服务的性能是会有所下降的。而当从服务出现问题时，主服务需要等待的时间就会更长，要等到从服务的服务恢复或者请求超时才能给用户响应")]),_._v(" "),e("hr"),_._v(" "),e("p",[e("code",[_._v("主从架构")]),_._v(" "),e("code",[_._v("互为主备")]),_._v(" "),e("code",[_._v("一主多从")]),_._v(" "),e("code",[_._v("多主多从")])]),_._v(" "),e("hr"),_._v(" "),e("h1",{attrs:{id:"_8-谈谈如何对mysql进行分库分表-多大数据量需要进行分库分表-分库分表的方式和-分片策略由哪些-分库分表后-sql语句的执行流程是怎样的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-谈谈如何对mysql进行分库分表-多大数据量需要进行分库分表-分库分表的方式和-分片策略由哪些-分库分表后-sql语句的执行流程是怎样的"}},[_._v("#")]),_._v(" 8. 谈谈如何对MySQL进行分库分表？多大数据量需要进行分库分表？分库分表的方式和 分片策略由哪些？分库分表后，SQL语句的执行流程是怎样的？")]),_._v(" "),e("p",[_._v("什么是分库分表？ 就是当表中的数据量过大时，整个查询效率就会降低得非常明显。这时为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表当中。")]),_._v(" "),e("p",[_._v("分库分表最常用的组件： "),e("code",[_._v("Mycat\\ ShardingSphere")])]),_._v(" "),e("p",[_._v("数据分片的方式有垂直分片和水平分片。垂直分片就是从业务角度将不同的表拆分\n到不同的库中，能够解决数据库数据文件过大的问题，但是不能从根本上解决查询\n问题。水平分片就是从数据角度将一个表中的数据拆分到不同的库或表中，这样可\n以从根本上解决数据量过大造成的查询效率低的问题。\n有非常多的分片策略，比如 "),e("code",[_._v("取模、按时间、按枚举值。。。。")])]),_._v(" "),e("p",[_._v("阿里提供的开发手册当中，建议："),e("code",[_._v("一个表的数据量超过500W或者数据文件超过2G，就要考虑分库分表了")])]),_._v(" "),e("p",[_._v("分库分表后的执行流程：")]),_._v(" "),e("p",[_._v("sql解析-》查询优化-》sql路由》sql改写-》sql执行-》结果合并")]),_._v(" "),e("p",[_._v("一个user表，按照userid进行了分片，然后我需要按照sex字段去查，这要怎么查？\n强制指定只查一个数据库，要怎么做？查询结果按照userid来排序，要怎么排？")]),_._v(" "),e("p",[_._v("分库分表的问题： "),e("code",[_._v("跨库查询、跨库排序、分布式事务、公共表、主键重复。。。。")]),_._v("。")]),_._v(" "),e("h1",{attrs:{id:"_9-mysql的锁有哪些-什么是间隙锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-mysql的锁有哪些-什么是间隙锁"}},[_._v("#")]),_._v(" 9. MySQL的锁有哪些？什么是间隙锁？")]),_._v(" "),e("p",[e("strong",[_._v("1、行锁")]),_._v("：加锁粒度小，但是加锁资源开销比较大。 InnDB支持。\n共享锁： "),e("code",[_._v("读锁")]),_._v("。多个事务可以对同一个数据共享同一把锁。持有锁的事务都可以\n访问数据，但是只能读不能修改。select xxx LOCK IN SHARE MODE。\n排他锁： "),e("code",[_._v("写锁")]),_._v("。只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。\nInnoDB会对update\\delete\\insert语句自动添加排他锁。SELECT xxx FOR\nUPDATE。\n自增锁： 通常是针对MySQL当中的自增字段。如果有事务回滚这种情况，数据\n会回滚，但是自增序列不会回滚。\n"),e("strong",[_._v("2、表锁")]),_._v("：加锁粒度大，加锁资源开销比较小。MyISAM和InnoDB都支持。\n"),e("code",[_._v("表共享读锁")]),_._v(" "),e("code",[_._v("表排他写锁")]),_._v("\n意向锁：是InnoDB自动添加的一种锁，不需要用户干预。\n3、全局锁： Flush tables with read lock 。 加锁之后整个数据库实例都处于只读\n状态。所有的数据变更操作都会被挂起。一般用于全库备份的时候。\n常见的锁算法： user: userid ( 1,4,9) update user set xxx where userid=5;\nREPEATABLE READ 间隙锁锁住(5,9)\n1、记录锁：锁一条具体的数据。\n2、"),e("code",[_._v("间隙锁")]),_._v("：RR隔离级别下，会加间隙锁。锁一定的范围，而不锁具体的记录。是\n为了防止产生幻读。(-xx,1)(1,4)(4,9)（9，xxx）\n3、"),e("code",[_._v("Next-key : 间隙锁+右记录锁")]),_._v("。(-xx,1](1,4](4,9]（9，xxx）")]),_._v(" "),e("p",[e("strong",[_._v("间隙锁实质上是对索引前后的间隙上锁，不对索引本身上锁")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("1. 乐观锁：并不会真正的去锁某⾏记录，⽽是通过⼀个版本号来实现的 \n2. 悲观锁：上⾯所的⾏锁、表锁等都是悲观锁\n")])])]),e("h1",{attrs:{id:"_10-mysql慢查询该如何优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-mysql慢查询该如何优化"}},[_._v("#")]),_._v(" 10. Mysql慢查询该如何优化？")]),_._v(" "),e("ol",[e("li",[_._v("检查是否"),e("code",[_._v("⾛了索引")]),_._v("，如果没有则优化SQL利⽤索引")]),_._v(" "),e("li",[_._v("检查所利⽤的索引，是否是最优索引")]),_._v(" "),e("li",[_._v("检查"),e("code",[_._v("所查字段是否都是必须的")]),_._v("，是否查询了过多字段，查出了多余数据")]),_._v(" "),e("li",[_._v("检查表中"),e("code",[_._v("数据是否过多")]),_._v("，是否应该进⾏分库分表了")]),_._v(" "),e("li",[_._v("检查数据库实例所在机器的"),e("code",[_._v("性能配置")]),_._v("，是否太低，是否可以适当增加资源")]),_._v(" "),e("li",[_._v("是否满足最左原则，是否使用like查询使索引失效，是否使用区间范围查询导致索引失效")]),_._v(" "),e("li")]),_._v(" "),e("h1",{attrs:{id:"_10-mysql索引失效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-mysql索引失效"}},[_._v("#")]),_._v(" 10. mysql索引失效")]),_._v(" "),e("ul",[e("li",[_._v("尽量全值匹配")]),_._v(" "),e("li",[_._v("最佳左前缀法则")]),_._v(" "),e("li",[_._v("不在索引列上做任何操作")]),_._v(" "),e("li",[_._v("范围条件放最后")]),_._v(" "),e("li",[_._v("覆盖索引尽量用")]),_._v(" "),e("li",[_._v("不等于大于小于要甚用")]),_._v(" "),e("li",[_._v("Null/Not 有影响")]),_._v(" "),e("li",[_._v("Like 查询要当心")]),_._v(" "),e("li",[_._v("隐形类型转换导致索引失效")])]),_._v(" "),e("h1",{attrs:{id:"_11-什么是mvcc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-什么是mvcc"}},[_._v("#")]),_._v(" 11. 什么是MVCC")]),_._v(" "),e("p",[e("strong",[_._v("多版本并发控制")]),_._v("：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，"),e("code",[_._v("版本链")])]),_._v(" "),e("p",[_._v("MVCC只在 "),e("code",[_._v("READ COMMITTED 和 REPEATABLE READ")]),_._v("两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 "),e("code",[_._v("READ UNCOMMITTED 总是读取最新的数据行")]),_._v(", 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有"),e("code",[_._v("读取的行都加锁")]),_._v("。")]),_._v(" "),e("p",[_._v("聚簇索引记录中有两个必要的隐藏列：\n"),e("strong",[_._v("trx_id")]),_._v("：用来存储每次对某条聚簇索引记录进行修改的时候的事务id。\n"),e("strong",[_._v("roll_pointer")]),_._v("：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个\nroll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)")]),_._v(" "),e("p",[e("code",[_._v("已提交读和可重复读的区别就在于它们生成ReadView的策略不同")]),_._v("。")]),_._v(" "),e("p",[_._v("开始事务时创建readview，readView维护当前活动的事务id，即未提交的事务id，排序生成一个数组\n访问数据，获取数据中的事务id（获取的是事务id最大的记录），对比readview： InnoDB redo log 写盘，InnoDB 事务进入 prepare 状态。\n如果前面 prepare 成功，binlog 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么 InnoDB 事务则进入 commit 状态(在 redo log 里面写一个 commit 记录)")]),_._v(" "),e("p",[_._v("已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。")]),_._v(" "),e("p",[_._v("这就是"),e("code",[_._v("Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别")]),_._v("。")]),_._v(" "),e("p",[_._v("**多版本并发控制：**可以理解成为类似与git化的版本管理，每次开一个事务会对整库进行快照并且生成对应的tx_id，每次发生修改记录对应的undo log。一致性读体现在各个事务在读的时候可以读取自己版本的数据，回滚则根据生成的undo logo段进行回滚即可")]),_._v(" "),e("p",[_._v("比如对于数据项A，它的数据版本为A1->A2->A3，最新版本是A3。如果事务X在读写数据项A时，A1和A2已提交的，事务Y正在修改A3，那么A3可以被提交，也可能被回滚。在使用锁协议时，事务X要等待Y结束，才能判断是否读到A3。在MVCC中，事务X可以读取已经提交的A2，而不必等待A3。这么操作逻辑上是合理的，因为事务X读到了一个最新的已经提交数据，这不会带来数据不一致，也避免了读写操作的冲突等待。在上面的情况中，X可以读到A2，如果X要写A怎么办？从逻辑上说，A3不确定是提交还是回滚，X必须等待Y结束，才能开始写操作，因此MVCC的写写操作是需要在数据对象上加写锁的，因此对于同一数据对象的写写操作，MVCC也是串行执行的。由于实际业务中读操作事务数量要大于写操作事务，MVCC读写不冲突（不加锁），写写冲突（加做）的机制，能够提高读事务的执行性能，从而提高系统的整体性能")]),_._v(" "),e("p",[_._v("mvcc\n对于数据项A，它的数据版本为A1->A2->A3，最新版本是A3。如果事务X在读写数据项A时，A1和A2已提交的，事务Y正在修改A3，那么A3可以被提交，也可能被回滚。在使用锁协议时，事务X要等待Y结束，才能判断是否读到A3。在MVCC中，事务X可以读取已经提交的A2，而不必等待A3。这么操作逻辑上是合理的，因为事务X读到了一个最新的已经提交数据，这不会带来数据不一致，也避免了读写操作的冲突等待。")]),_._v(" "),e("p",[_._v("在上面的情况中，X可以读到A2,如果X要写A怎么办？会不会 XY事务串行执行，会不会覆盖对方的操作？？？")]),_._v(" "),e("h1",{attrs:{id:"_12-什么是脏读、幻读、不可重复读-要怎么处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-什么是脏读、幻读、不可重复读-要怎么处理"}},[_._v("#")]),_._v(" 12. 什么是脏读、幻读、不可重复读？要怎么处理？")]),_._v(" "),e("p",[_._v("这些问题都是MySQL进行事务并发控制时经常遇到的问题。\n"),e("code",[_._v("脏读")]),_._v("： 在事务进行过程中，读到了其他事务未提交的数据。\n"),e("code",[_._v("不可重复读")]),_._v("： 在一个事务过程中，多次查询的结果不一致。\n"),e("code",[_._v("幻读")]),_._v("： 在一个事务过程中，用同样的操作查询数据，得到的记录数不相同。")]),_._v(" "),e("p",[e("strong",[_._v("处理的方式有很多种：加锁、事务隔离、MVCC")])]),_._v(" "),e("p",[e("code",[_._v("加锁")]),_._v("：")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("脏读")]),_._v("：在修改时加排他锁，直到事务提交才释放。读取时加共享锁，读完释放锁。")]),_._v(" "),e("li",[e("code",[_._v("不可重复读")]),_._v("： 读数据时加共享锁，写数据时加排他锁。")]),_._v(" "),e("li",[e("code",[_._v("幻读")]),_._v("： 加范围锁。")])]),_._v(" "),e("h1",{attrs:{id:"_14-事务的基本特性和隔离级别有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-事务的基本特性和隔离级别有哪些"}},[_._v("#")]),_._v(" 14. 事务的基本特性和隔离级别有哪些？")]),_._v(" "),e("p",[e("strong",[_._v("事务")]),_._v("： 表示多个数据操作组成一个完整的事务单元，这个事务内的所有数据操作要么同时成功，要么同时失败。")]),_._v(" "),e("p",[e("strong",[_._v("事务的特性：ACID")])]),_._v(" "),e("ol",[e("li",[_._v("原子性：事务是不可分割的，要么完全成功，要么完全失败。")]),_._v(" "),e("li",[_._v("一致性：事务无论是完成还是失败，都必须保持事务内操作的一致性。当失败时，都要对前面的操作进行回滚，不管中途是否成功。")]),_._v(" "),e("li",[_._v("隔离性：当多个事务操作一个数据的时候，为防止数据损坏，需要将每个事务进行隔离，互相不干扰。")]),_._v(" "),e("li",[_._v("持久性： 事务开始就不会终止。他的结果不受其他外在因素的影响。")])]),_._v(" "),e("p",[_._v("事务的隔离级别：SHOW VARIABLES like 'transaction%'\n设置隔离级别： set transaction level xxx 设置下次事务的隔离级别。\nset session transaction level xxx 设置当前会话的事务隔离级别\nset global transaction level xxx 设置全局事务隔离级别")]),_._v(" "),e("p",[e("strong",[_._v("MySQL当中有五种隔离级别")])]),_._v(" "),e("ul",[e("li",[_._v("NONE ： 不使用事务。")]),_._v(" "),e("li",[_._v("READ UNCOMMITED：允许脏读")]),_._v(" "),e("li",[_._v("READ COMMITED：  防止脏读，最常用的隔离级别")]),_._v(" "),e("li",[_._v("REPEATABLE READ：防止脏读和不可重复读。MYSQL默认")]),_._v(" "),e("li",[_._v("SERIALIZABLE： 事务串行，可以防止脏读、幻读，不可重复度。")])]),_._v(" "),e("p",[_._v("五种隔离级别，级别越高，"),e("code",[_._v("事务的安全性是更高的，但是事务的并性能也就会越低")])]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("索引结构、慢查询优化、ACID、事务隔离级别、MVCC、分库分表")]),_._v(" "),e("p",[_._v("索引类型：覆盖索引，聚簇索引；索引数据结构、索引失效")]),_._v(" "),e("p",[_._v("慢查询\nSQL优化\nEXPLAIN")]),_._v(" "),e("p",[_._v("分库分表模式\n分库分表策略\n分库分表相关技术\nbinglog日志同步方式")]),_._v(" "),e("h2",{attrs:{id:"acid事务隔离级别脏读幻读问题mvcc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#acid事务隔离级别脏读幻读问题mvcc"}},[_._v("#")]),_._v(" ACID\n事务隔离级别\n脏读幻读问题\nMVCC")])])}),[],!1,null,null,null);v.default=s.exports}}]);