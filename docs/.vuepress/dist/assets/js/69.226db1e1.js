(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{1037:function(t,a,s){t.exports=s.p+"assets/img/kafka06.5cf73e3f.jpg"},1038:function(t,a,s){t.exports=s.p+"assets/img/rebalance.6d4846f5.jpg"},1039:function(t,a,s){t.exports=s.p+"assets/img/kafka07.cb3e8760.jpg"},1040:function(t,a,s){t.exports=s.p+"assets/img/HWLED.3d4b1a2a.jpg"},1041:function(t,a,s){t.exports=s.p+"assets/img/HWLED1.fba878db.jpg"},1042:function(t,a,s){t.exports=s.p+"assets/img/kafka08.689cb439.jpg"},1587:function(t,a,s){"use strict";s.r(a);var r=s(26),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_4-kafka设计原理详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-kafka设计原理详解"}},[t._v("#")]),t._v(" 4. Kafka设计原理详解")]),t._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#_4-1-核心组件介绍"}},[t._v("4.1 核心组件介绍")]),r("ul",[r("li",[r("a",{attrs:{href:"#_4-1-1isr"}},[t._v("4.1.1ISR")])]),r("li",[r("a",{attrs:{href:"#_4-1-2-kafka核心总控制器controller"}},[t._v("4.1.2 Kafka核心总控制器Controller")])])])]),r("li",[r("a",{attrs:{href:"#_4-2-controller选举机制"}},[t._v("4.2 Controller选举机制")])]),r("li",[r("a",{attrs:{href:"#_4-3-partition副本选举leader机制"}},[t._v("4.3 Partition副本选举Leader机制")])]),r("li",[r("a",{attrs:{href:"#_4-4-消费者消费消息的offset记录机制"}},[t._v("4.4 消费者消费消息的offset记录机制")])]),r("li",[r("a",{attrs:{href:"#_4-5-消费者rebalance机制"}},[t._v("4.5 消费者Rebalance机制")]),r("ul",[r("li",[r("a",{attrs:{href:"#_4-5-1-rebalance过程如下"}},[t._v("4.5.1 Rebalance过程如下")])])])]),r("li",[r("a",{attrs:{href:"#_4-6-producer发布消息机制剖析"}},[t._v("4.6 producer发布消息机制剖析")]),r("ul",[r("li",[r("a",{attrs:{href:"#_4-6-1-写入方式"}},[t._v("4.6.1 写入方式")])]),r("li",[r("a",{attrs:{href:"#_4-6-2-消息路由"}},[t._v("4.6.2 消息路由")])]),r("li",[r("a",{attrs:{href:"#_4-6-3-写入流程"}},[t._v("4.6.3 写入流程")])])])]),r("li",[r("a",{attrs:{href:"#_4-7-hw与leo详解"}},[t._v("4.7 HW与LEO详解")])]),r("li",[r("a",{attrs:{href:"#_4-8-日志分段存储"}},[t._v("4.8 日志分段存储")])])])]),r("p"),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"kafka",href:"./image/kafka06.jpg"}},[r("img",{attrs:{src:s(1037),alt:"kafka"}})])]),t._v(" "),r("p",[t._v("我们在此之前先创建一个主题topic，方便后边介绍")]),t._v(" "),r("div",{staticClass:"language-sh line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-sh"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#副本数设置为3，分区数设置为3")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("root@YUN01 bin"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ./kafka-topics.sh --create --zookeeper 101.43.21.33:2181 --replication-factor 3 --partitions 3 --topic tqk002")]),t._v("\nCreated topic "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tqk002"')]),r("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v("\n\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 三个borker主机的id 分别是 0 ，2 , 3")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看主题")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("root@YUN01 bin"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ./kafka-topics.sh  --zookeeper 101.43.21.33:2181 --topic tqk002 --describe")]),t._v("\nTopic:tqk002\tPartitionCount:3\tReplicationFactor:3\tConfigs:\n\tTopic: tqk002\tPartition: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\tLeader: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\tReplicas: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0,2")]),t._v(",3\tIsr: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0,2")]),t._v(",3\n\tTopic: tqk002\tPartition: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\tLeader: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\tReplicas: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2,3")]),t._v(",0\tIsr: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2,3")]),t._v(",0\n\tTopic: tqk002\tPartition: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\tLeader: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\tReplicas: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("3,0")]),t._v(",2\tIsr: "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("3,0")]),t._v(",2\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br"),r("span",{staticClass:"line-number"},[t._v("10")]),r("br"),r("span",{staticClass:"line-number"},[t._v("11")]),r("br")])]),r("h2",{attrs:{id:"_4-1-核心组件介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-核心组件介绍"}},[t._v("#")]),t._v(" 4.1 核心组件介绍")]),t._v(" "),r("h3",{attrs:{id:"_4-1-1isr"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1isr"}},[t._v("#")]),t._v(" 4.1.1ISR")]),t._v(" "),r("p",[t._v("也即 In-Sync Replica。每个 Partition 的 Leader 都会维护这样一个列表，该列表中，包含了所有与之同步的 Replica（包含 Leader 自己）。")]),t._v(" "),r("p",[r("font",{attrs:{color:"red"}},[t._v("每次数据写入时，只有 ISR 中的所有 Replica 都复制完，Leader 才会将其置为 Commit，它才能被 Consumer 所消费")]),t._v("。")],1),t._v(" "),r("h3",{attrs:{id:"_4-1-2-kafka核心总控制器controller"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-2-kafka核心总控制器controller"}},[t._v("#")]),t._v(" 4.1.2 Kafka核心总控制器Controller")]),t._v(" "),r("p",[t._v("在Kafka集群中会有一个或者多个broker，其中有一个broker会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态。")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。")])]),t._v(" "),r("li",[r("p",[t._v("当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。")])]),t._v(" "),r("li",[r("p",[t._v("当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由控制器负责分区的重新分配。")])])]),t._v(" "),r("h2",{attrs:{id:"_4-2-controller选举机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-controller选举机制"}},[t._v("#")]),t._v(" 4.2 Controller选举机制")]),t._v(" "),r("p",[t._v("在kafka集群启动的时候，会自动选举一台broker作为controller来管理整个集群，选举的过程是集群中每个broker都会 "),r("strong",[t._v("尝试在zookeeper上创建一个 "),r("font",{attrs:{color:"red"}},[t._v("/controller 临时节点")])],1),t._v("，zookeeper会保证有且仅有一个broker能创建成功，这个broker 就会成为集群的总控器controller。")]),t._v(" "),r("p",[r("strong",[t._v("当这个controller角色的broker宕机")]),t._v("了，此时zookeeper临时节点会消失，集群里其他broker会一直监听这个临时节点，发现临时节点消失了，就竞争再次创建临时节点，就是我们上面说的选举机制，zookeeper又会保证有一个broker 成为新的controller。")]),t._v(" "),r("p",[r("strong",[t._v("具备控制器身份的broker需要比其他普通的broker多一份职责")]),t._v("，具体细节如下：")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[r("font",{attrs:{color:"red"}},[t._v("broker职责")])],1),t._v(" "),r("ol",[r("li",[r("p",[r("strong",[t._v("监听broker相关的变化")]),t._v("。为Zookeeper中的/brokers/ids/节点"),r("strong",[t._v("添加BrokerChangeListener")]),t._v("，用来处理broker 增减的变化。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("监听topic相关的变化")]),t._v("。为Zookeeper中的/brokers/topics节点"),r("strong",[t._v("添加TopicChangeListener")]),t._v("，用来处理topic增减的变化；\n为Zookeeper中的/admin/delete_topics节点添加TopicDeletionListener，用来处理删除topic的动作。")])]),t._v(" "),r("li",[r("p",[t._v("从Zookeeper中读取获取当前所有与topic、partition以及broker有关的信息并进行相应的管理。")]),t._v(" "),r("p",[t._v("对于所有topic所对应的Zookeeper中的/brokers/topics/topic节点"),r("strong",[t._v("添加PartitionModificationsListener")]),t._v("，用来监听topic中的分区分配变化。")])]),t._v(" "),r("li",[r("p",[t._v("更新集群的元数据信息，同步到其他普通的broker节点中。")])])])]),t._v(" "),r("div",{staticClass:"language-cpp line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-cpp"}},[r("code",[r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("root@YUN01 bin"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("# "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("root"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("apache"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("zookeeper"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.6")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("bin"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("bin"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("zkCli"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sh\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("zk"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" localhost"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2181")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CONNECTED"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" ls "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("admin"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" brokers"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" cluster"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" config"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" consumers"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" controller"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" controller_epoch"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" isr_change_notification"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" latest_producer_id_block"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" log_dir_event_notification"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" zookeeper"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("zk"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" localhost"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2181")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CONNECTED"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" ls "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("brokers"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ids\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("zk"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" localhost"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2181")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CONNECTED"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" ls "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("brokers"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("topics\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("__consumer_offsets"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mytopic"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" test777"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tqk001"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tqk002"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tqkjiqun"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br")])]),r("h2",{attrs:{id:"_4-3-partition副本选举leader机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-partition副本选举leader机制"}},[t._v("#")]),t._v(" 4.3 Partition副本选举Leader机制")]),t._v(" "),r("p",[t._v("controller感知到分区leader所在的broker挂了(controller监听了很多zk节点可以感知到broker存活)，controller会从每 个parititon的 replicas 副本列表中取出第一个broker作为leader，当然这个broker需要也同时在ISR列表里。")]),t._v(" "),r("h2",{attrs:{id:"_4-4-消费者消费消息的offset记录机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-消费者消费消息的offset记录机制"}},[t._v("#")]),t._v(" 4.4 消费者消费消息的offset记录机制")]),t._v(" "),r("p",[t._v("每个consumer会定期将自己消费分区的offset提交给kafka内部topic：__consumer_offsets，提交过去的时候，")]),t._v(" "),r("p",[r("strong",[t._v("key是 consumerGroupId+topic+分区号")]),t._v("，"),r("strong",[t._v("value就是当前offset的值")]),t._v("，kafka会定期清理topic里的消息，最后就保留最新的那条数据")]),t._v(" "),r("p",[t._v("因为__consumer_offsets可能会接收高并发的请求，kafka默认给其分配50个分区(可以通过 offsets.topic.num.partitions设置)，这样可以通过加机器的方式抗大并发。")]),t._v(" "),r("h2",{attrs:{id:"_4-5-消费者rebalance机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-消费者rebalance机制"}},[t._v("#")]),t._v(" 4.5 消费者Rebalance机制")]),t._v(" "),r("p",[t._v("消费者rebalance就是说"),r("strong",[t._v("如果consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者")]),t._v("，")]),t._v(" "),r("p",[t._v("如果他又重启了，那么又会把一些分区重新交还给他如下情况可能会触发消费者rebalance")]),t._v(" "),r("ol",[r("li",[t._v("consumer所在服务重启或宕机了")]),t._v(" "),r("li",[t._v("动态给topic增加了分区")]),t._v(" "),r("li",[t._v("消费组订阅了更多的topic")])]),t._v(" "),r("h3",{attrs:{id:"_4-5-1-rebalance过程如下"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-1-rebalance过程如下"}},[t._v("#")]),t._v(" 4.5.1 Rebalance过程如下")]),t._v(" "),r("p",[t._v("当有消费者加入消费组时，消费者、消费组及组协调器之间会经历以下几个阶段")]),t._v(" "),r("h4",{attrs:{id:"第一阶段-选择组协调器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一阶段-选择组协调器"}},[t._v("#")]),t._v(" 第一阶段：选择组协调器")]),t._v(" "),r("p",[r("strong",[t._v("组协调器GroupCoordinator")]),t._v("：每个consumer group都会选择一个broker作为自己的"),r("strong",[t._v("组协调器coordinator")]),t._v("，负责监控这个消费组里的所有消费者的心跳，以及判断是否宕机，然后开启消费者rebalance。")]),t._v(" "),r("p",[t._v("consumer group中的每个consumer启动时会向kafka集群中的某个节点发送 FindCoordinatorRequest 请求来查找对应的组协调器GroupCoordinator，并跟其建立网络连接。")]),t._v(" "),r("p",[r("strong",[t._v("组协调器选择方式")]),t._v(" ：通过如下公式可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区，这个分区leader对应的broker 就是这个consumer group的coordinator")]),t._v(" "),r("p",[r("strong",[t._v("公式：hash(consumer group id) % __consumer_offsets主题的分区数")])]),t._v(" "),r("h4",{attrs:{id:"第二阶段-加入消费组join-group"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二阶段-加入消费组join-group"}},[t._v("#")]),t._v(" 第二阶段：加入消费组JOIN GROUP")]),t._v(" "),r("p",[t._v("在成功找到消费组所对应的 GroupCoordinator 之后就进入加入消费组的阶段，在此阶段的消费者会向 GroupCoordinator 发送 JoinGroupRequest 请求，并处理响应。")]),t._v(" "),r("p",[t._v("然后GroupCoordinator 从一个consumer group中 选择第一个加入group的consumer作为"),r("strong",[t._v("leader(消费组协调器)")]),t._v("，把consumer group情况发送给这个leader，接着这个leader会负责制定分区方案。")]),t._v(" "),r("h4",{attrs:{id:"第三阶段-sync-group"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第三阶段-sync-group"}},[t._v("#")]),t._v(" 第三阶段（ SYNC GROUP)")]),t._v(" "),r("p",[t._v("consumer leader通过给GroupCoordinator发送SyncGroupRequest，接着GroupCoordinator就把分区方案下发给各个consumer，他们会根据指定分区的leader broker进行网络连接以及消息消费。")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"kafka",href:"./image/rebalance.jpg"}},[r("img",{attrs:{src:s(1038),alt:"kafka"}})])]),t._v(" "),r("h4",{attrs:{id:"消费者rebalance分区分配策略-主要有三种rebalance的策略-range、round-robin、sticky。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费者rebalance分区分配策略-主要有三种rebalance的策略-range、round-robin、sticky。"}},[t._v("#")]),t._v(" 消费者Rebalance分区分配策略： 主要有三种rebalance的策略：range、round-robin、sticky。")]),t._v(" "),r("p",[t._v("Kafka 提供了消费者客户端参数partition.assignment.strategy 来设置消费者与订阅主题之间的分区分配策略。")]),t._v(" "),r("p",[r("strong",[t._v("默认情况为range分配策略")]),t._v("。 假设一个主题有10个分区(0-9)，现在有三个consumer消费： range策略就是按照分区序号排序，假设 n＝分区数／消费者数量 = 3， m＝分区数%消费者数量 = 1，那么前 m 个消 费者每个分配 n+1 个分区，后面的（消费者数量－m ）个消费者每个分配 n 个分区。 比如分区0~3给一个consumer，分区4~6给一个consumer，分区7~9给一个consumer。")]),t._v(" "),r("p",[r("strong",[t._v("round-robin策略就是轮询分配")]),t._v("，比如分区0、3、6、9给一个consumer，分区1、4、7给一个consumer，分区2、5、 8给一个consumer")]),t._v(" "),r("p",[r("strong",[t._v("sticky策略")]),t._v("就是在rebalance的时候，需要保证如下两个原则。")]),t._v(" "),r("ol",[r("li",[t._v("分区的分配要尽可能均匀 。")]),t._v(" "),r("li",[t._v("分区的分配尽可能与上次分配的保持相同。")])]),t._v(" "),r("p",[t._v("当两者发生冲突时，第一个目标优先于第二个目标 。这样可以最大程度维持原来的分区分配的策略。 比如对于第一种range情况的分配，如果第三个consumer挂了，那么重新用sticky策略分配的结果如下： consumer1除了原有的0~3，会再分配一个7 consumer2除了原有的4~6，会再分配8和9")]),t._v(" "),r("h2",{attrs:{id:"_4-6-producer发布消息机制剖析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-producer发布消息机制剖析"}},[t._v("#")]),t._v(" 4.6 producer发布消息机制剖析")]),t._v(" "),r("h3",{attrs:{id:"_4-6-1-写入方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-1-写入方式"}},[t._v("#")]),t._v(" 4.6.1 写入方式")]),t._v(" "),r("p",[t._v("producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，"),r("strong",[t._v("属于顺序写磁盘")]),t._v("（顺序写磁盘 效率比随机写内存要高，保障 kafka 吞吐率）。")]),t._v(" "),r("h3",{attrs:{id:"_4-6-2-消息路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-2-消息路由"}},[t._v("#")]),t._v(" 4.6.2 消息路由")]),t._v(" "),r("p",[t._v("producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。\n其路由机制为：")]),t._v(" "),r("ol",[r("li",[t._v("指定了 patition，则直接使用；")]),t._v(" "),r("li",[t._v("未指定 patition 但指定 key，通过对 key 的 value 进行hash 选出一个 patition")]),t._v(" "),r("li",[t._v("patition 和 key 都未指定，使用轮询选出一个 patition。")])]),t._v(" "),r("h3",{attrs:{id:"_4-6-3-写入流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-3-写入流程"}},[t._v("#")]),t._v(" 4.6.3 写入流程")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"kafka",href:"./image/kafka07.jpg"}},[r("img",{attrs:{src:s(1039),alt:"kafka"}})])]),t._v(" "),r("ol",[r("li",[t._v('producer 先从 zookeeper 的 "/brokers/.../state" 节点找到该 partition 的 leader')]),t._v(" "),r("li",[t._v("producer 将消息发送给该 leader")]),t._v(" "),r("li",[t._v("leader 将消息写入本地 log")]),t._v(" "),r("li",[t._v("followers 从 leader pull 消息，写入本地 log 后 向leader 发送 ACK")]),t._v(" "),r("li",[t._v("leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，\n最后 commit 的 offset） 并向 producer 发送 ACK")])]),t._v(" "),r("h2",{attrs:{id:"_4-7-hw与leo详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-hw与leo详解"}},[t._v("#")]),t._v(" 4.7 HW与LEO详解")]),t._v(" "),r("p",[r("strong",[t._v("HW俗称高水位")]),t._v("，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO(log-end-offset)作为HW， consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状 态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW， 此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获 取。对于来自内部broker的读取请求，没有HW的限制。")]),t._v(" "),r("p",[t._v("下图详细的说明了当producer生产消息至broker后，ISR以及HW和LEO的流转过程：")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"kafka",href:"./image/HWLED.jpg"}},[r("img",{attrs:{src:s(1040),alt:"kafka"}})])]),t._v(" "),r("p",[t._v("由此可见，Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的follower都复制完，这 条消息才会被commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，follower异步的从leader复制数据，数据只要被leader写 入log就被认为已经commit，这种情况下如果follower都还没有复制完，落后于leader时，突然leader宕机，则会丢失数据。而Kafka的这 种使用ISR的方式则很好的均衡了确保数据不丢失以及吞吐率。再回顾下消息发送端对发出消息持久化机制参数acks的设置，我们结合HW 和LEO来看下acks=1的情况")]),t._v(" "),r("p",[r("strong",[t._v("结合HW和LEO看下 acks=1的情况")]),t._v(" "),r("a",{attrs:{"data-fancybox":"",title:"kafka",href:"./image/HWLED1.jpg"}},[r("img",{attrs:{src:s(1041),alt:"kafka"}})])]),t._v(" "),r("h2",{attrs:{id:"_4-8-日志分段存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-日志分段存储"}},[t._v("#")]),t._v(" 4.8 日志分段存储")]),t._v(" "),r("p",[t._v("Kafka 一个分区的消息数据对应存储在一个文件夹下，以topic名称+分区号命名，kafka规定了一个分区内的 .log 文件 最大为 1G，"),r("strong",[t._v("做这个限制目的是为了方便把 .log 加载到内存去操作：(读取时使用)")])]),t._v(" "),r("div",{staticClass:"language-sh line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-sh"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 部分消息的offset索引文件，kafka每次往分区发4K(可配置)消息就会记录一条当前消息的offset到index文件， ")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果要定位消息的offset会先在这个文件里快速定位，再去log文件里找具体消息 ")]),t._v("\n00000000000000000000.index \n\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 消息存储文件，主要存offset和消息体 ")]),t._v("\n00000000000000000000.log \n\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 消息的发送时间索引文件，kafka每次往分区发4K(可配置)消息就会记录一条当前消息的发送时间戳与对应的offset到timeindex文件， ")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果需要按照时间来定位消息的offset，会先在这个文件里查找 ")]),t._v("\n00000000000000000000.timeindex \n00000000000005367851.index \n00000000000005367851.log \n00000000000005367851.timeindex \n00000000000009936472.index \n00000000000009936472.log \n00000000000009936472.timeindex\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br"),r("span",{staticClass:"line-number"},[t._v("10")]),r("br"),r("span",{staticClass:"line-number"},[t._v("11")]),r("br"),r("span",{staticClass:"line-number"},[t._v("12")]),r("br"),r("span",{staticClass:"line-number"},[t._v("13")]),r("br"),r("span",{staticClass:"line-number"},[t._v("14")]),r("br"),r("span",{staticClass:"line-number"},[t._v("15")]),r("br"),r("span",{staticClass:"line-number"},[t._v("16")]),r("br")])]),r("p",[t._v("这个 9936472 之类的数字，就是代表了这个日志段文件里包含的起始 Offset，也就说明这个分区里至少都写入了接近 1000 万条数据了。 Kafka Broker 有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是 1GB。 一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做 log rolling，正在被写入的那个日志段文件，叫做 active log segment。")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"kafka",href:"./image/kafka08.jpg"}},[r("img",{attrs:{src:s(1042),alt:"kafka"}})])])])}),[],!1,null,null,null);a.default=e.exports}}]);