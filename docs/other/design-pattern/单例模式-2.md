
# 单例模式（Singleton Pattern）
单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

:::tip 注意：
1、单例类只能有一个实例。  
2、单例类必须自己创建自己的唯一实例。  
3、单例类必须给所有其他对象提供这一实例。  
:::

## 单例(Singleton)设计模式-饿汉式

描述：这种方式比较常用，但容易产生垃圾对象。  
优点：没有加锁，执行效率会提高。  
缺点：类加载时就初始化，浪费内存。  

```java
/**
 * 单例模式-懒汉式（静态常量模式）
 */
public class HungrySingleton {
    //私有化构造，防止new创建对象
    private  HungrySingleton(){}
    //创建静态常量对象
    private static HungrySingleton hungrySingleton=new HungrySingleton();
    //提供静态公用方法
    public static HungrySingleton getHungrySingleton() {
        return hungrySingleton;
    }
}
```

```java
/**
 * 单例模式-懒汉式（静态代码块）
 */
public class HungrySingleton1 {
    // 私有化构造，防止new创建对象
    private  HungrySingleton1(){}
    // 创建静态常量对象
    private static HungrySingleton1 hungrySingleton;
    // 静态代码块
    static {
        hungrySingleton=new HungrySingleton1();
    }
    // 提供静态公用方法
    public static HungrySingleton1 getHungrySingleton() {
        return hungrySingleton;
    }
}
```

## 单例(Singleton)设计模式-懒汉式

优点：第一次调用才初始化，避免内存浪费。  
缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。

**线程不安全，不推荐使用** 
1. 起到了Lazy Loading的效果，但是只能在单线程下使用。
2. 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式

```java
public class LazySingleton {
    //私有化构造器
    private LazySingleton(){
    }
    //创建私有对象，未实例化
    private static  LazySingleton lazySingleton;
    //创建获取对象的方法，线程不安全，不推荐
    public LazySingleton getLazySingleton(){
        if(lazySingleton==null){
            lazySingleton =new LazySingleton();
        }
        return lazySingleton;
    }
}
```

**同步方法方式，效率低，不推荐使用**

```java
public class Order {
    // 1.私有化构造方法
    private  Order(){}
    // 静态的实例化对象
    private static Order order=null;
    // 返回对象的方法 ，需要时创建,同步方法
    public synchronized  static Order getOrder(){
        if(order==null){
            //并发时，存在线程安全问题，加synchronized锁处理
            order=new Order();
        }
        return order;
    }
}
```
1. 解决了线程不安全问题
2. 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行
同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低

**双重校验锁 提高代码性能 同步代码块 推荐使用**

```java
public class Order2 {
    // 1.私有化构造方法
    private  Order2(){}
    // 静态的实例化对象
    private static Order2 order=null;
    // 返回对象的方法 ，需要时创建
    public  static Order2 getOrder(){
        if(order==null){
            //同步代码块
            synchronized(Order2.class){
                if(order==null){
                    //并发时，存在线程安全问题，加synchronized锁处理
                    order=new Order2();
                }
            }
        }
        return order;
    }
}
```
1. Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。
2. 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步.
3. 线程安全；延迟加载；效率较高


**静态内部类方式**

```java
/**
 * 懒汉式-静态内部类方式
 */
public class LazySingleton3 {
    private  LazySingleton3(){}
    // 静态内部类使用到才加载，所以起到了延迟加载的作用
    private static class LazySingletonIn{
        private final static LazySingleton3 lazySingleton3=new LazySingleton3();
    }
    public static LazySingleton3 getLazySingleton(){
        return LazySingletonIn.lazySingleton3;
    }
}
```
1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
2. 静态内部类方式在LazySingleton3类被装载时并不会立即实例化，而是在需要实例化时，调用getLazySingleton方法，才会装载LazySingletonIn类，从而完成LazySingleton3的实例化。
3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，**JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的**。
4. 优点：<font color='red'>避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</font>

**枚举方式**

