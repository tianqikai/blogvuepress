
# 单例模式（Singleton Pattern）
单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

:::tip 注意：
1、单例类只能有一个实例。  
2、单例类必须自己创建自己的唯一实例。  
3、单例类必须给所有其他对象提供这一实例。  
:::

## 单例(Singleton)设计模式-饿汉式

描述：这种方式比较常用，但容易产生垃圾对象。  
优点：没有加锁，执行效率会提高。  
缺点：类加载时就初始化，浪费内存。  

```java
public class BankCard {
    // 1.私有化构造器

    private  BankCard(){

    }
    // 2.内部提供一个当前类的实例
    // 3.此实例也必须静态化
    private  static BankCard bankCard=new BankCard();

    // 4.提供公共的静态的方法，返回当前类的对象

    public  static  BankCard getBankCard(){
        return bankCard;
    }
}
```

## 单例(Singleton)设计模式-懒汉式

优点：第一次调用才初始化，避免内存浪费。  
缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。  

```java
public class Order {
    // 1.私有化构造方法
    private  Order(){

    }
    // 静态的实例化对象
    private static Order order=null;
    // 返回对象的方法 ，需要时创建
    /**
     * @Method： getOrder
     * @Description：获取order实例
     */
    public synchronized  static Order getOrder(){
        if(order==null){
            //并发时，存在线程安全问题，加synchronized锁处理
            order=new Order();
        }
        return order;
    }
}
```

**双重校验锁 提高代码性能**

```java
public class Order2 {
    // 1.私有化构造方法
    private  Order2(){

    }
    // 静态的实例化对象
    private static Order2 order=null;
    // 返回对象的方法 ，需要时创建
    /**
     * @Method： getOrder
     * @Description：获取order实例
     */
    public   static Order2 getOrder(){
        if(order==null){
            synchronized(Order2.class){
                if(order==null){
                    //并发时，存在线程安全问题，加synchronized锁处理
                    order=new Order2();
                }
            }
        }
        return order;
    }
}
```
