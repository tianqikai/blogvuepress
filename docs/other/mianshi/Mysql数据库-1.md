# 1. ACID靠什么保证的？

- A 原子性由`undo log日志`保证，它记录了需要`回滚的日志信息`，事务回滚时撤销已经执行成功的sql
- C 一致性由其他三大特性保证、程序代码要保证业务上的一致性
- I 隔离性由`MVCC来保证`
- D 持久性由`内存+redo log`来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从`redo log恢复`

# 2. B树和B+树的区别，为什么Mysql使⽤B+树

**B树特点：**
1. 节点排序 
2. ⼀个节点了可以存多个元素，多个元素也排序了

**B+树的特点：** 
1. 拥有B树的特点 
2. 叶⼦节点之间有指针 
3. `⾮叶⼦节点上的元素在叶⼦节点上都冗余`了，也就是叶⼦节点中存储了所有的元素，并且排好顺序

Mysql索引使⽤的是B+树，因为索引是⽤来加快查询的，⽽B+树通过对数据进⾏排序所以是可以提⾼查询 速度的，然后通过⼀个节点中可以存储多个元素，从⽽可以使得B+树的⾼度不会太⾼，在Mysql中⼀个 Innodb⻚就是⼀个B+树节点，⼀个Innodb⻚默认16kb，所以⼀般情况下⼀颗两层的B+树可以存2000万 ⾏左右的数据，然后通过利⽤B+树叶⼦节点存储了所有数据并且进⾏了排序，并且叶⼦节点之间有指针， 可以很好的⽀持全表扫描，范围查找等SQL语句

# 3. Explain执行计划的各个字段是干什么用的？

id： 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id
select_type： SELECT 关键字对应的那个查询的类型
table：表名
partitions：匹配的分区信息
type：针对单表的访问方法
possible_keys：可能用到的索引
key：实际上使用的索引
key_len：实际使用到的索引长度
ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息
rows：预估的需要读取的记录条数
filtered：某个表经过搜索条件过滤后剩余记录条数的百分比
Extra：—些额外的信息

2. selectType 表示查询中每个select子句的类型
    SIMPLE： 表示此查询不包含 UNION 查询或子查询
    PRIMARY： 表示此查询是最外层的查询（包含子查询）
    SUBQUERY： 子查询中的第一个 SELECT
    UNION： 表示此查询是 UNION 的第二或随后的查询
    DEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询
    UNION RESULT, UNION 的结果
    DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.
    DERIVED：衍生，表示导出表的SELECT（FROM子句的子查询）

4. type：优化sql的重要字段，也是我们判断sql性能和优化程度重要指标。他的取值类型范围：
    const：通过索引一次命中，匹配一行数据
    system: 表中只有一行记录，相当于系统表；
    eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配
    ref: 非唯一性索引扫描,返回匹配某个值的所有
    range: 只检索给定范围的行，使用一个索引来选择行，一般用于between、<、>；
    index: 只遍历索引树；
    ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多，执行效率越慢。

# 4. Innodb是如何实现事务的

Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例： 
1. Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在`Buffer Pool` 中 
2. 执⾏update语句，修改`Buffer Pool`中的数据，也就是内存中的数据 
3. 针对update语句⽣成⼀个`RedoLog对象`，并存⼊`LogBuffer中 `
4. 针对update语句⽣成undolog⽇志，⽤于事务回滚 
5. 如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将`Buffer Pool中所修改的数据⻚持久化到磁盘中 `
6. 如果事务回滚，则利⽤undolog⽇志进⾏回滚


# 5. MySQL的索引结构是什么样的

聚簇索引就是数据和索引是在一起的。

- MyISAM使用的是非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址。InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。

- 聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。

- InnoDB中，如果表定义了PK，`那PK就是聚簇索引`。 如果没有PK，就会找第一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。

# 6 MySQL的覆盖索引和回表
如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查
询，这样查询速度就可以更快。
实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。
user（PK id , name ,sex）
select count(name) from user ; -> 在name 字段上建立一个索引。
select id , name ,sex from user; -> 将name上的索引升级成为(name,sex)的联合
索引。

# 7. MySQL的集群是如何搭建的？读写分离是怎么做的？

这时，主库上会有一个`IO dump线程`，负责通过这个TCP连接把Binlog日志传输给从库的IO线程。接着从服务的`IO线程`会把读取到的`binlog日志`数据写入自己的relay日志文件中。

然后从服务上另外一个`SQL线程`会读取relay日志里的内容，进行操作重演，达到还原数据的目的。我们通常对MySQL做的读写分离配置就必须基于主从架构来搭建

主从架构异步复制可能存在丢数据的情况，可以使用`半同步方式`

这种半同步复制相比异步复制，能够有效的提高数据的安全性。但是这种安全性也不是绝对的，他只保证事务提交后的binlog至少传输到了一个从库，并且并不保证从库应用这个事务的binlog是成功的。另一方面，半同步复制机制也会造成一定程度的延迟，这个延迟时间最少是一个TCP/IP请求往返的时间。整个服务的性能是会有所下降的。而当从服务出现问题时，主服务需要等待的时间就会更长，要等到从服务的服务恢复或者请求超时才能给用户响应

--------------------------------------------

`主从架构`
`互为主备`
`一主多从`
`多主多从`

--------------------------------------------


# 8. 谈谈如何对MySQL进行分库分表？多大数据量需要进行分库分表？分库分表的方式和 分片策略由哪些？分库分表后，SQL语句的执行流程是怎样的？

什么是分库分表？ 就是当表中的数据量过大时，整个查询效率就会降低得非常明显。这时为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表当中。

分库分表最常用的组件： `Mycat\ ShardingSphere`

数据分片的方式有垂直分片和水平分片。垂直分片就是从业务角度将不同的表拆分
到不同的库中，能够解决数据库数据文件过大的问题，但是不能从根本上解决查询
问题。水平分片就是从数据角度将一个表中的数据拆分到不同的库或表中，这样可
以从根本上解决数据量过大造成的查询效率低的问题。
有非常多的分片策略，比如 `取模、按时间、按枚举值。。。。`

阿里提供的开发手册当中，建议：`一个表的数据量超过500W或者数据文件超过2G，就要考虑分库分表了`

分库分表后的执行流程：

sql解析-》查询优化-》sql路由》sql改写-》sql执行-》结果合并

一个user表，按照userid进行了分片，然后我需要按照sex字段去查，这要怎么查？
强制指定只查一个数据库，要怎么做？查询结果按照userid来排序，要怎么排？

分库分表的问题： `跨库查询、跨库排序、分布式事务、公共表、主键重复。。。。`。

# 9. MySQL的锁有哪些？什么是间隙锁？

**1、行锁**：加锁粒度小，但是加锁资源开销比较大。 InnDB支持。
共享锁： `读锁`。多个事务可以对同一个数据共享同一把锁。持有锁的事务都可以
访问数据，但是只能读不能修改。select xxx LOCK IN SHARE MODE。
排他锁： `写锁`。只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。
InnoDB会对update\delete\insert语句自动添加排他锁。SELECT xxx FOR
UPDATE。
自增锁： 通常是针对MySQL当中的自增字段。如果有事务回滚这种情况，数据
会回滚，但是自增序列不会回滚。
**2、表锁**：加锁粒度大，加锁资源开销比较小。MyISAM和InnoDB都支持。
`表共享读锁`
`表排他写锁`
意向锁：是InnoDB自动添加的一种锁，不需要用户干预。
3、全局锁： Flush tables with read lock 。 加锁之后整个数据库实例都处于只读
状态。所有的数据变更操作都会被挂起。一般用于全库备份的时候。
常见的锁算法： user: userid ( 1,4,9) update user set xxx where userid=5; 
REPEATABLE READ 间隙锁锁住(5,9)
1、记录锁：锁一条具体的数据。
2、`间隙锁`：RR隔离级别下，会加间隙锁。锁一定的范围，而不锁具体的记录。是
为了防止产生幻读。(-xx,1)(1,4)(4,9)（9，xxx）
3、`Next-key : 间隙锁+右记录锁`。(-xx,1](1,4](4,9]（9，xxx）



**间隙锁实质上是对索引前后的间隙上锁，不对索引本身上锁**
 
    1. 乐观锁：并不会真正的去锁某⾏记录，⽽是通过⼀个版本号来实现的 
    2. 悲观锁：上⾯所的⾏锁、表锁等都是悲观锁
# 10. Mysql慢查询该如何优化？

1. 检查是否`⾛了索引`，如果没有则优化SQL利⽤索引 
2. 检查所利⽤的索引，是否是最优索引 
3. 检查`所查字段是否都是必须的`，是否查询了过多字段，查出了多余数据 
4. 检查表中`数据是否过多`，是否应该进⾏分库分表了 
5. 检查数据库实例所在机器的`性能配置`，是否太低，是否可以适当增加资源
6. 是否满足最左原则，是否使用like查询使索引失效，是否使用区间范围查询导致索引失效
7. 

# 10. mysql索引失效

- 尽量全值匹配
- 最佳左前缀法则
- 不在索引列上做任何操作
- 范围条件放最后
- 覆盖索引尽量用
- 不等于大于小于要甚用
- Null/Not 有影响
- Like 查询要当心
- 隐形类型转换导致索引失效


# 11. 什么是MVCC

**多版本并发控制**：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，`版本链`

MVCC只在 `READ COMMITTED 和 REPEATABLE READ `两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 `READ UNCOMMITTED 总是读取最新的数据行`, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有`读取的行都加锁`。

聚簇索引记录中有两个必要的隐藏列：
**trx_id**：用来存储每次对某条聚簇索引记录进行修改的时候的事务id。
**roll_pointer**：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个
roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)

`已提交读和可重复读的区别就在于它们生成ReadView的策略不同`。

开始事务时创建readview，readView维护当前活动的事务id，即未提交的事务id，排序生成一个数组
访问数据，获取数据中的事务id（获取的是事务id最大的记录），对比readview： InnoDB redo log 写盘，InnoDB 事务进入 prepare 状态。 
如果前面 prepare 成功，binlog 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么 InnoDB 事务则进入 commit 状态(在 redo log 里面写一个 commit 记录) 


已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

这就是`Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别`。

**多版本并发控制：**可以理解成为类似与git化的版本管理，每次开一个事务会对整库进行快照并且生成对应的tx_id，每次发生修改记录对应的undo log。一致性读体现在各个事务在读的时候可以读取自己版本的数据，回滚则根据生成的undo logo段进行回滚即可


比如对于数据项A，它的数据版本为A1->A2->A3，最新版本是A3。如果事务X在读写数据项A时，A1和A2已提交的，事务Y正在修改A3，那么A3可以被提交，也可能被回滚。在使用锁协议时，事务X要等待Y结束，才能判断是否读到A3。在MVCC中，事务X可以读取已经提交的A2，而不必等待A3。这么操作逻辑上是合理的，因为事务X读到了一个最新的已经提交数据，这不会带来数据不一致，也避免了读写操作的冲突等待。在上面的情况中，X可以读到A2，如果X要写A怎么办？从逻辑上说，A3不确定是提交还是回滚，X必须等待Y结束，才能开始写操作，因此MVCC的写写操作是需要在数据对象上加写锁的，因此对于同一数据对象的写写操作，MVCC也是串行执行的。由于实际业务中读操作事务数量要大于写操作事务，MVCC读写不冲突（不加锁），写写冲突（加做）的机制，能够提高读事务的执行性能，从而提高系统的整体性能

mvcc
对于数据项A，它的数据版本为A1->A2->A3，最新版本是A3。如果事务X在读写数据项A时，A1和A2已提交的，事务Y正在修改A3，那么A3可以被提交，也可能被回滚。在使用锁协议时，事务X要等待Y结束，才能判断是否读到A3。在MVCC中，事务X可以读取已经提交的A2，而不必等待A3。这么操作逻辑上是合理的，因为事务X读到了一个最新的已经提交数据，这不会带来数据不一致，也避免了读写操作的冲突等待。

在上面的情况中，X可以读到A2,如果X要写A怎么办？会不会 XY事务串行执行，会不会覆盖对方的操作？？？

# 12. 什么是脏读、幻读、不可重复读？要怎么处理？

这些问题都是MySQL进行事务并发控制时经常遇到的问题。
`脏读`： 在事务进行过程中，读到了其他事务未提交的数据。
`不可重复读`： 在一个事务过程中，多次查询的结果不一致。
`幻读`： 在一个事务过程中，用同样的操作查询数据，得到的记录数不相同。

**处理的方式有很多种：加锁、事务隔离、MVCC**

`加锁`：
1. `脏读`：在修改时加排他锁，直到事务提交才释放。读取时加共享锁，读完释放锁。
2. `不可重复读`： 读数据时加共享锁，写数据时加排他锁。
3. `幻读`： 加范围锁。


# 14. 事务的基本特性和隔离级别有哪些？

**事务**： 表示多个数据操作组成一个完整的事务单元，这个事务内的所有数据操作要么同时成功，要么同时失败。

**事务的特性：ACID**
1. 原子性：事务是不可分割的，要么完全成功，要么完全失败。
2. 一致性：事务无论是完成还是失败，都必须保持事务内操作的一致性。当失败时，都要对前面的操作进行回滚，不管中途是否成功。
3. 隔离性：当多个事务操作一个数据的时候，为防止数据损坏，需要将每个事务进行隔离，互相不干扰。
4. 持久性： 事务开始就不会终止。他的结果不受其他外在因素的影响。

事务的隔离级别：SHOW VARIABLES like 'transaction%'
设置隔离级别： set transaction level xxx 设置下次事务的隔离级别。
set session transaction level xxx 设置当前会话的事务隔离级别
set global transaction level xxx 设置全局事务隔离级别

**MySQL当中有五种隔离级别**
- NONE ： 不使用事务。
- READ UNCOMMITED：允许脏读
- READ COMMITED：  防止脏读，最常用的隔离级别
- REPEATABLE READ：防止脏读和不可重复读。MYSQL默认
- SERIALIZABLE： 事务串行，可以防止脏读、幻读，不可重复度。

五种隔离级别，级别越高，`事务的安全性是更高的，但是事务的并性能也就会越低`

--------------------------------------------

索引结构、慢查询优化、ACID、事务隔离级别、MVCC、分库分表

索引类型：覆盖索引，聚簇索引；索引数据结构、索引失效

慢查询
SQL优化
EXPLAIN

分库分表模式
分库分表策略
分库分表相关技术
binglog日志同步方式


ACID
事务隔离级别
脏读幻读问题
MVCC
-----------------------------------------