# 9.集合

## 9.1 Java集合框架概述

<strong>Java 集合可分为 Collection 和 Map 两种体系</strong>  
※ <font color='red'>Collection接口</font>：单列数据，定义了存取一组对象的方法的集合  
　◆ <font color='red'>List</font>：元素有序. 可重复的集合  
　◆ <font color='red'>Set</font>：元素无序. 不可重复的集合  
※ <font color='red'> Map接口</font>：双列数据，保存具有映射关系“key-value对”的集合  

### Collection继承树

![Collection](../image/Collection.png)

### Map继承树
![Map](../image/map.png)

## 9.2 Collection接口方法

**Collection 接口**  
● Collection 接口是 List. Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。   
● JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。   
● 在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。  

1. 添加  
<font color='red'>▷  add(Object obj)</font>  
<font color='red'>▷  addAll(Collection coll)</font>    
2. 获取有效元素的个数  
<font color='red'>▷  int size()</font>   
3. 清空集合  
<font color='red'>▷  void clear()</font>   
4. 是否是空集合   
<font color='red'>▷  boolean isEmpty()</font>   
5. 是否包含某个元素  
<font color='red'>▷  boolean contains(Object obj)</font> ：是通过元素的equals方法来判断是否是同一个对象  
<font color='red'>▷  boolean containsAll(Collection c)</font> ：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。   
6. 删除  
<font color='red'>▷  boolean remove(Object obj)</font>  ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素  
<font color='red'>▷  boolean removeAll(Collection coll)</font> ：取当前集合的差集  
7. 取两个集合的交集   
<font color='red'>▷  boolean retainAll(Collection c)</font> ：把交集的结果存在当前集合中，不影响c  
8. 集合是否相等  
<font color='red'>▷  boolean equals(Object obj)</font>   
9. 转成对象数组  
<font color='red'>▷  Object[] toArray()</font>   
10. 获取集合对象的哈希值  
<font color='red'>▷  hashCode()</font>   
11. 遍历  
<font color='red'>▷  iterator()</font> ：返回迭代器对象，用于集合遍历  



## 9.3 Iterator迭代器接口

:::tip
1. Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。
2. GOF给迭代器模式的定义为：<font color='red'>提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。<strong>迭代器模式，就是为容器而生</strong></font>。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 
3. Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 
4. <font color='blue'>Iterator 仅用于遍历集合</font>，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。
5. <font color='red'>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前</font>。
:::

:::tip 注意：
1. 在调用it.next()方法之前必须要调用it.hasNext()进行检测。<strong>若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常</strong>。
2. Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。 
3. 如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，<strong>再调用remove都会报IllegalStateException</strong>。
:::

## 9.4 Collection子接口一：List

:::tip List的方法
1. <font color='red'>void add(int index, Object ele)</font>:在index位置插入ele元素
2. <font color='red'>boolean addAll(int index, Collection eles)</font>:从index位置开始将eles中的所有元素添加进来
3. <font color='red'>Object get(int index)</font>:获取指定index位置的元素
4. <font color='red'>int indexOf(Object obj)</font>:返回obj在集合中首次出现的位置
5. <font color='red'>int lastIndexOf(Object obj)</font>:返回obj在当前集合中末次出现的位置
6. <font color='red'>Object remove(int index)</font>:移除指定index位置的元素，并返回此元素
7. <font color='red'>Object set(int index, Object ele)</font>:设置指定index位置的元素为ele
8. <font color='red'>List subList(int fromIndex, int toIndex)</font>:返回从fromIndex到toIndex位置的子集合
:::

### List实现类之一：ArrayList
ArrayList 是 List 接口的典型实现类、主要实现类
本质上，ArrayList是对象引用的一个”变长”数组
ArrayList的JDK1.8之前与之后的实现区别？
 JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组
 JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元
素时再创建一个始容量为10的数组
Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是
Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合


### List实现类之二：LinkedList
 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高
 新增方法：
 void addFirst(Object obj)  void addLast(Object obj) 
 Object getFirst()
 Object getLast()
 Object removeFirst()
 Object removeLast()

 LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，
用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基
本结构。Node除了保存数据，还定义了两个变量：
 prev变量记录前一个元素的位置
 next变量记录下一个元素的位置

----
### List实现类之三：Vector
Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList
相同，区别之处在于Vector是线程安全的。
在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，
使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。
新增方法：
 void addElement(Object obj)  void insertElementAt(Object obj,int index)
 void setElementAt(Object obj,int index)
 void removeElement(Object obj)  void removeAllElements()


面试题：
请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? 
 ArrayList和LinkedList的异同
二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因ArrayList要移动数据。
 ArrayList和Vector的区别
Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于
强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用
ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大
小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。

## 9.5 Collection子接口二：Set
Set 接口概述
 Set接口是Collection的子接口，set接口没有提供额外的方法
 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个
Set 集合中，则添加操作失败。
 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法


Set实现类之一：HashSet
HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。
HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 
HashSet 具有以下特点：
不能保证元素的排列顺序
HashSet 不是线程安全的
集合元素可以是 null
HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相
等，并且两个对象的 equals() 方法返回值也相等。 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object 
obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。


## 9.6 Map接口

## 9.7 Collections工具类