# 9.集合

:::tip 数组在内存存储方面的特点：
1. 数组初始化以后，长度就确定了。 
2. 数组声明的类型，就决定了进行元素初始化时的类型 
:::

:::warning 数组在存储数据方面的弊端： 
1. 数组初始化以后，长度就不可变了，不便于扩展  
2. 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数  
3. 数组存储的数据是有序的、可以重复的。---->存储数据的特点单一  
:::

## 9.1 Java集合框架概述

<strong>Java 集合可分为 Collection 和 Map 两种体系</strong>  
※ <font color='red'><strong>Collection接口</strong></font>：单列数据，定义了存取一组对象的方法的集合  
　√ <font color='red'><strong>List</strong></font>：元素有序. 可重复的集合  
　√ <font color='red'><strong>Set</strong></font>：元素无序. 不可重复的集合  
※ <font color='red'><strong> Map接口</strong></font>：双列数据，保存具有映射关系“key-value对”的集合  

### Collection继承树

![Collection](../image/Collection.png)

### Map继承树
![Map](../image/map.png)

## 9.2 Collection接口方法

**Collection 接口**  
● Collection 接口是 List. Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。   
● JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。   
● 在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。  

1. 添加  
<font color='red'>▷  add(Object obj)</font>  
<font color='red'>▷  addAll(Collection coll)</font>    
2. 获取有效元素的个数  
<font color='red'>▷  int size()</font>   
3. 清空集合  
<font color='red'>▷  void clear()</font>   
4. 是否是空集合   
<font color='red'>▷  boolean isEmpty()</font>   
5. 是否包含某个元素  
<font color='red'>▷  boolean contains(Object obj)</font> ：是通过元素的equals方法来判断是否是同一个对象  
<font color='red'>▷  boolean containsAll(Collection c)</font> ：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。   
6. 删除  
<font color='red'>▷  boolean remove(Object obj)</font>  ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素  
<font color='red'>▷  boolean removeAll(Collection coll)</font> ：取当前集合的差集  
7. 取两个集合的交集   
<font color='red'>▷  boolean retainAll(Collection c)</font> ：把交集的结果存在当前集合中，不影响c  
8. 集合是否相等  
<font color='red'>▷  boolean equals(Object obj)</font>   
9. 转成对象数组  
<font color='red'>▷  Object[] toArray()</font>   
10. 获取集合对象的哈希值  
<font color='red'>▷  hashCode()</font>   
11. 遍历  
<font color='red'>▷  iterator()</font> ：返回迭代器对象，用于集合遍历  

```java
public class CollectionTest {
    public static void main(String[] args) {
        List<String> list=new ArrayList<>();
        list.add("000");
        list.add("111");
        list.add("222");
        list.add("333");
        list.add("444");
        list.add("555");
        list.add("666");
        list.add("777");
        list.add("888");
        list.add("999");
        Iterator iterator=list.iterator();
        while(iterator.hasNext()){
            System.out.println("value:"+iterator.next());
        }
        System.out.println("---------------------------");
        list.remove("444");
        Iterator iterator2=list.iterator();
        while(iterator2.hasNext()){
            System.out.println(iterator2.next());
        }
        System.out.println("--------------");
        System.out.println(list.get(0));
        System.out.println(list.size());
        System.out.println(list.indexOf("222"));
        System.out.println(list.isEmpty());
        for(String str:list){
            System.out.println("value:"+str);
        }

    }
}
```

## 9.3 Iterator迭代器接口

:::tip
1. Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。
2. GOF给迭代器模式的定义为：<font color='red'>提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。<strong>迭代器模式，就是为容器而生</strong></font>。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 
3. Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 
4. <font color='blue'>Iterator 仅用于遍历集合</font>，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。
5. <font color='red'>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前</font>。
:::

:::tip 注意：
1. 在调用it.next()方法之前必须要调用it.hasNext()进行检测。<strong>若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常</strong>。
2. Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。 
3. 如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，<strong>再调用remove都会报IllegalStateException</strong>。
:::

## 9.4 Collection子接口一：List

:::tip List的方法
1. <font color='red'>void add(int index, Object ele)</font>:在index位置插入ele元素
2. <font color='red'>boolean addAll(int index, Collection eles)</font>:从index位置开始将eles中的所有元素添加进来
3. <font color='red'>Object get(int index)</font>:获取指定index位置的元素
4. <font color='red'>int indexOf(Object obj)</font>:返回obj在集合中首次出现的位置
5. <font color='red'>int lastIndexOf(Object obj)</font>:返回obj在当前集合中末次出现的位置
6. <font color='red'>Object remove(int index)</font>:移除指定index位置的元素，并返回此元素
7. <font color='red'>Object set(int index, Object ele)</font>:设置指定index位置的元素为ele
8. <font color='red'>List subList(int fromIndex, int toIndex)</font>:返回从fromIndex到toIndex位置的子集合
:::

### List实现类之一：ArrayList
1. ArrayList 是 List 接口的典型实现类、主要实现类
2. 本质上，ArrayList是对象引用的一个”变长”数组
3. ArrayList的JDK1.8之前与之后的实现区别？  
　<font color='red'>JDK1.7：ArrayList像饿汉式</font>，直接创建一个初始容量为10的数组  
　<font color='red'>JDK1.8：ArrayList像懒汉式</font>，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组  
4. Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合

```java
public class ArrayListTest {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        updateList(list);
        System.out.println(list);
        System.out.println("----------------");
        list.set(1,5);
        System.out.println(list);
        System.out.println(list.get(0));
        System.out.println(list.size());
        System.out.println(list.indexOf("222"));
        //内部还是用的迭代器
        for(Integer i:list){
            System.out.println(i);
        }
    }
    private static void updateList(List list) {
        list.remove(2);//按下标remove 所以3被移除
    }
}
```


### List实现类之二：LinkedList
<font color='red'><strong> 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</strong></font>  

<strong>新增方法：</strong>  
1. <font color='red'><strong>void addFirst(Object obj)</strong></font>   
2. <font color='red'><strong>void addLast(Object obj)</strong></font>   
3. <font color='red'><strong>Object getFirst()</strong></font>  
4. <font color='red'><strong>Object getLast()</strong></font>  
5. <font color='red'><strong>Object removeFirst()</strong></font>  
6. <font color='red'><strong>Object removeLast()</strong></font> 

```java

```

<font color='red'><strong>LinkedList：双向链表</strong></font> ，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：
 ◆ prev变量记录前一个元素的位置
 ◆ next变量记录下一个元素的位置

```java
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```
![LinkedList](../image/LinkedList.png)

---------

### List实现类之三：Vector
<strong>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，<font color='blue'>区别之处在于Vector是线程安全的</font></strong>。  
<strong>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</strong>  

**新增方法：**
<font color='blue'><strong> void addElement(Object obj) </strong></font>  
<font color='blue'><strong> void insertElementAt(Object obj,int index)</strong></font>  
<font color='blue'><strong> void setElementAt(Object obj,int index)</strong></font>  
<font color='blue'><strong> void removeElement(Object obj) </strong></font>  
<font color='blue'><strong> void removeAllElements()</strong></font>  


**面试题：**
请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? 
<font color='blue'><strong>三者都实现了List，存储数据有序，可重复</strong></font>
Vector： 线程安全，执行效率慢，底层是 Object[] elementData 数组
ArrayList： 线程不安全，执行效率高，底层是 Object[] elementData 数组
LinkedList：线程不安全，执行效率高，底层双向链表

1. ArrayList和LinkedList的异同  
二者都线程不安全，相对线程安全的Vector，执行效率高。   
此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。    
对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。   
对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因ArrayList要移动数据。   
2. ArrayList和Vector的区别  
Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类;因此开销就比ArrayList要大，访问要慢。  
正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。  
<font color='red'>Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack</font>。  

## 9.5 Collection子接口二：Set

**Set 接口概述** 
1. Set接口是Collection的子接口，set接口没有提供额外的方法
2. Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。  
3. Set 判断两个对象是否相同不是使用 == 运算符，而是<font color='red'>根据 equals() 方法</font>  


### Set实现类之一：HashSet
1. HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。
2. HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 


:::tip <font color='blue'>HashSet 具有以下特点：</font>
1. 不能保证元素的排列顺序
2. HashSet 不是线程安全的
3. 集合元素可以是 null
4. HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。 
5. <font color='red'><strong>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</strong></font>
:::

### Set实现类之二：LinkedHashSet
LinkedHashSet 是 HashSet 的子类
LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，
但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入
顺序保存的。
LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全
部元素时有很好的性能。
LinkedHashSet 不允许集合元素重复。

### Set实现类之三：TreeSet
TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。
TreeSet底层使用红黑树结构存储数据
 新增的方法如下： (了解) 
Comparator comparator()
Object first()
Object last()
Object lower(Object e)
Object higher(Object e)
SortedSet subSet(fromElement, toElement) 
SortedSet headSet(toElement) 
SortedSet tailSet(fromElement) 
TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。



### 排 序—自然排序
自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元
素之间的大小关系，然后将集合元素按升序(默认情况)排列
如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 
接口。
实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过
compareTo(Object obj) 方法的返回值来比较大小。  Comparable 的典型实现：
BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小
进行比较
Character：按字符的 unicode值来进行比较
Boolean：true 对应的包装类实例大于 false 对应的包装类实例
String：按字符串中字符的 unicode 值进行比较
Date、Time：后边的时间、日期比前面的时间、日期大
向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添
加的所有元素都会调用compareTo()方法进行比较。
因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同
一个类的对象。
对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通
过 compareTo(Object obj) 方法比较返回值。
当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保
证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过
equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。
否则，让人难以理解。
### 排 序—定制排序
TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没
有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照
其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来
实现。需要重写compare(T o1,T o2)方法。 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表
示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构
造器。
此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异
常。
使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。
## 9.6 Map接口

## 9.7 Collections工具类