# java并发编程高级

## linux上启动一个线程的代码

<font color='red'>**关于操作系统的线程 linux操作系统的线程控制原语**</font>

``` cpp
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
```
---------------------------

```cpp
//tqkThread.c
//头文件 
#include <pthread.h> 
#include <stdio.h> 
//定义一个变量，接受创建线程后的线程id 
pthread_t pid; //定义线程的主体函数
void* thread_entity(void* arg) {
    printf("i am new Thread! from c"); 
}
//main方法，程序入口，main和java的main一样会产生一个进程，继而产生一个main线程 
int main() {
    /*调用操作系统的函数创建线程，注意四个参数 */
    pthread_create(&pid,NULL,thread_entity,NULL); 
    //usleep是睡眠的意思，那么这里的睡眠是让谁睡眠呢？ 
    //为什么需要睡眠？如果不睡眠会出现什么情况 
    usleep(100); 
    printf("main\n"); 
}
```
```java
//编译命令 带上-pthread 库文件
gcc tqkThread.c  -pthread

//执行编译后的可执行文件 ./a.out

[root@VM-0-8-centos C]# ./a.out
i am new Thread! from cmain

```

## 在java代码里启动一个线程的代码

```java
public class Example4Start { 
    public static void main(String[] args) {
         Thread thread = new Thread(){
            @Override public void run() {
                System.out.println("i am new Thread! from java ");
            } 
        };
        thread.start(); 
    } 
}

/**--------------------start方法的源码的部分----------------**/
// start0()是native方法，这是java虚拟机调用了底层c库实现的
  public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
    private native void start0();
```

:::warning <font color='red'>native关键字</font>
**native主要用于方法上**    
1. 一个native方法就是一个Java调用<font color='red'>**非Java代码的接口**</font>。一个native方法是指该方法的实现由非Java语言实现，比如用C或C++实现。
2. 在定义一个native方法时，并不提供实现体（比较像定义一个Java Interface），因为其实现体是由非Java语言在外面实现的主要是因为JAVA无法对操作系统底层进行操作，但是可以通过<font color='red'><strong>JNI(java native interface)</strong></font>调用其他语言来实现底层的访问。
:::


## 手写Java线程类操动操作系统级别线程

<font color='red'><strong>在没有openjdk的情况下，我们做一个大胆的猜测，java级别的线程其实就是操作系统级别的线程，什么意思呢？说白了我们大胆猜想 star----->start0------------>ptherad_create</strong></font>>

**本地方法的代码编写**

```cpp
//thread.c
#include <pthread.h> 
#include <stdio.h> 
//定义变量接受线程id 
pthread_t pid; 
//线程的主体方法相当于 java当中的run 
void* thread_entity(void* arg) { 
    //子线程死循环 
    while(1){ 
        //睡眠100毫秒 
        usleep(100); 
        //打印 
        printf("I am new Thread\n"); 
    } 
}
//c语言的主方法入口方法，相当于java的main 
int main() { 
    //调用linux的系统的函数创建一个线程 
    pthread_create(&pid,NULL,thread_entity,NULL); 
    //主线程死循环 
    while(1){ 
        //睡眠100毫秒 
        usleep(100); 
        //打印 
        printf("I am main\n"); 
    }
    return 0;
}
```

:::tip 在linux上编译、运行上述C程序
编译这个程序(-o 标识指定编译后的文件名，也可以不指定，默认为a.out)
```shell
gcc thread.c -o thread.out -pthread
```
运行这个程序
```bash
./thread.out
```
运行结果
```bash
I am main
I am new Thread
I am main
I am new Thread
I am main
I am new Thread
I am main
I am new Thread
```
:::


**java利用JNI调用本地方法**
```java
public class EnjoyThread { 
    //装载库，保证JVM在启动的时候就会装载，故而一般是也给static 
    static { 
        System.loadLibrary( "EnjoyThreadNative" ); 
    }
    public static void main(String[] args) { 
        EnjoyThread enjoyThread =new EnjoyThread();
        enjoyThread.start0(); 
    }
    private native void start0(); 
}
```

:::warning
1. 编译java文件最好是在包的目录下面运行javac命令
```bash
javac EnjoyThread.java
```
生成EnjoyThread.class的文件
2. 利用javac -h . xx.java命令 来编译一个头文件
```bash
javac -h . EnjoyThred.java
```
3. 创建一个新的c文件

```cpp
//thread.c
#include <pthread.h>
#include <stdio.h>
//JNI头文件
#include <jni.h>

//定义变量接受线程id
pthread_t pid;
//线程的主体方法相当于 java当中的run
void* thread_entity(void* arg) {
    //子线程死循环
    while(1){
        //睡眠100毫秒
        usleep(100);
        //打印
        printf("I am new Thread\n");
    }
}
//Java_EnjoyThread_start0 查看 EnjoyThred.h获取； 后边两个参数固定
JNICALL Java_EnjoyThread_start0(JNIEnv *env, jobject c1) {
    //调用linux的系统的函数创建一个线程
    pthread_create(&pid,NULL,thread_entity,NULL);
    //主线程死循环
    while(1){
        //睡眠100毫秒
        usleep(100);
        //打印
        printf("I am main\n");
    }
    return 0;
}
```

4. 编译这个threadNew.c生成动态库文件，这样才能被java程序加载到

```bash 
gcc -fPIC -I /usr/java/jdk1.8.0_211-amd64/include -I /usr/java/jdk1.8.0_211-amd64/include/linux -shared -o libxxx.so threadNew.c
//注意这个libxxx; lib是固定的xxx可以随意，但是得和你的java代码中的System.loadLibrary( "xxx" );对应
gcc -fPIC -I /usr/java/jdk1.8.0_211-amd64/include -I /usr/java/jdk1.8.0_211-amd64/include/linux -shared -o libEnjoyThreadNative.so threadNew.c
```
5. 把so文件所在的目录添加到系统变量，不然java还是load不到

```bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/Learn/C
最后运行我们前面写好的那个java文件(记得到包的外面去运行java命令)
java EnjoyThread
```
:::
<!-- # 1.什么是线程安全问题
# 2.如何解决线程安全的问题
# 3.synchronized锁的基本用法
# 4.synchronized死锁问题
# 5.springmvc 接口中使用 如何保证线程安全问题
# 6.多线程之间如何实现通讯
# 7.wait/notify/notifyAll基本用法
# 8.多线程通讯实现生产者与消费者
# 9.Join与sleep之间的区别
# 10.Join底层是如何执行的
# 11.三个线程 T1，T2，T3，怎么确保它们按顺序执行？
# 12.线程间通讯
# 13.volatile关键字是否能保证线程安全 -->
