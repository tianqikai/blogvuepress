# 7. 线程池

## 7.1 线程池好处

Java 中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行 任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来 3 个好处。


### 7.1.1 降低资源消耗。

通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

### 7.1.2 提高响应速度。

当任务到达时，任务可以不需要等到线程创建就能立 即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线 程中执行任务的时间，T3 销毁线程时间。 如果：T1 + T3 远大于 T2，则可以 采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整 T1,T3 时 间的技术，从而提高服务器程序性能的。它把 T1，T3 分别安排在服务器程序的 启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时， 不会有 T1，T3 的开销了。 

### 7.1.3 提高线程的可管理性。

线程是稀缺资源，如果无限制地创建，不仅会 消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和 监控。假设一个服务器一天要处理 50000 个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池 中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为 50000。 一般线程池大小是远小于 50000。所以利用线程池的服务器程序不会为了创建 50000 而在处理请求时浪费时间，从而提高效率

## 7.2 线程池参数含义

```java
public ThreadPoolExecutor(int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue<Runnable> workQueue,
ThreadFactory threadFactory,
RejectedExecutionHandler handler)
```


### 7.2.1 corePoolSize 

线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize； 

如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行； 

如果执行了线程池的 prestartAllCoreThreads()方法，线程池会提前创建并启 动所有核心线程

### 7.2.2 maximumPoolSize 

线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize

### 7.2.3 keepAliveTime 

线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于 corePoolSize 时才有用

TimeUnit   
keepAliveTime 的时间单位  
workQueue  

workQueue 必须是 BlockingQueue 阻塞队列。当线程池中的线程数超过它的 corePoolSize 的时候，线程会进入阻塞队列进行阻塞等待。通过 workQueue，线程池实现了阻塞功能


### 7.2.4 workQueue 

用于保存等待执行的任务的阻塞队列，一般来说，我们应该尽量使用有界队 列，因为使用无界队列作为工作队列会对线程池带来如下影响。 

1. 当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待， 因此线程池中的线程数不会超过 corePoolSize。 
2. 由于 1，使用无界队列时 maximumPoolSize 将是一个无效参数。 
3. 由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数。 
4. 更重要的，使用无界 queue 可能会耗尽系统资源，有界队列则有助于防 止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。

所以我们一般会使用，ArrayBlockingQueue、LinkedBlockingQueue、 SynchronousQueue、PriorityBlockingQueue。

### 7.2.4 threadFactory 

创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具 有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。

参见代码 cn.enjoyedu.ch6.ThreadPoolAdv 

Executors 静态工厂里默认的 threadFactory，线程的命名规则是“pool-数字 -thread-数字”


### 7.2.5 RejectedExecutionHandler 

线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提 交任务，必须采取一种策略处理该任务，线程池提供了 4 种策略：

1. AbortPolicy：直接抛出异常，默认策略； 
2. CallerRunsPolicy：用调用者所在的线程来执行任务； 
3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； 
4. DiscardPolicy：直接丢弃任务； 

当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和 策略，如记录日志或持久化存储不能处理的任务。

## 7.3 自定义线程池

```java
package com.tqk.pool.mythreadpool;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/**
 *类说明：自定义线程池实现
 */
public class MyThreadPool {
    /*缺省线程数据量*/
    private static int WORK_COUNT=5;
    /*存放任务*/
    private final BlockingQueue<Runnable> taskQueue;
    /*工作线程数组*/
    private WorkThread[] workThreads;

    private final int work_number;

    public MyThreadPool(){
        this(100,WORK_COUNT);
    }

    // todo 任务数，线程的数量
    public MyThreadPool(int task_count,
                         int work_number) {
        //todo 如果工作线程数未输入，采用默认值
        if (work_number<=0) {
            work_number = WORK_COUNT;
        }
        //todo 最大线程数
        if(task_count<=0) {
            task_count = 100;
        }
        this.taskQueue = new ArrayBlockingQueue<>(task_count);
        this.work_number = work_number;
        //todo 创建线程数组-》线程池
        workThreads = new WorkThread[work_number];
        //todo 工作线程准备好了
        for(int i=0;i<work_number;i++){
            workThreads[i] = new WorkThread();
            workThreads[i].start();
        }
    }

    /**
     * 销毁线程池
     */
    public void destroy(){
        System.out.println("ready close pool....");
        for(int i=0;i<work_number;i++){
            workThreads[i].stopWorker();
            workThreads[i] = null;//help gc
        }
        taskQueue.clear();
    }

    /**
     * 放入任务，但是只是加入队列
     * @param task
     */
    public void execute(Runnable task){
        try {
            taskQueue.put(task);
        } catch (InterruptedException e) {
            throw new RuntimeException("加入队列失败");
        }

    }
    /**
     * 内部类，工作线程的实现
     */
    private  class WorkThread extends  Thread{
        @Override
        public void run() {
            Runnable r = null;
            try {
                //todo 判断是否中断处理
                while(!isInterrupted()){
                    //todo 获取到队列中一个任务线程
                    r = taskQueue.take();
                    if(r!=null){
                        System.out.println(getId()+" ready execute" +((TestMyThreadPool.MyTask)r).getName());
                        r.run();
                    }
                    r = null;
                }
            } catch (InterruptedException e) {
//                System.out.println(e);
//                throw new RuntimeException("创建工作线程失败");
            }
        }

        //todo 停止工作
        public void stopWorker() {
            //todo 中断处理
            interrupt();
        }
    }
}
```

### 测试类

```java
package com.tqk.pool.mythreadpool;

import java.util.Random;

/**
 *类说明：测试自定义线程池实现
 */
public class TestMyThreadPool {
    public static void main(String[] args) throws InterruptedException {
//         创建3个线程的线程池
        MyThreadPool t = new MyThreadPool(0,3);
        t.execute(new MyTask("testA"));
        t.execute(new MyTask("testB"));
        t.execute(new MyTask("testC"));
        t.execute(new MyTask("testD"));
        t.execute(new MyTask("testE"));
        System.out.println(t);
        Thread.sleep(10000);
        t.destroy();// 所有线程都执行完成才destory
        System.out.println(t);
    }

    // 任务类
    static class MyTask implements Runnable {

        private String name;
        private Random r = new Random();

        public MyTask(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        @Override
        public void run() {// 执行任务
            //int x =10;
            try {
                Thread.sleep(r.nextInt(1000)+2000);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getId()+" sleep InterruptedException:"
                        +Thread.currentThread().isInterrupted());
            }
            System.out.println("任务 " + name + " 完成");
        }
    }
}
```

